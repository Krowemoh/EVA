*
* COMPILER DIRECTIVES
*
    $DEFINE DATABASE.UV
    $DEFINE PLATFORM.LINUX
*
*ASI********************************************************************
*                                                                      *
* Copyright 2022 - Asynchron Systems Inc.                              *
*                                                                      *
* THIS PROGRAM IS THE EXCLUSIVE PROPERTY OF ASYNCHRON SYSTEMS INC. IT  *
* MAY NOT BE USED, SOLD, DISTRIBUTED OR REPRODUCED BY ANY MEANS WITHOUT*
* THE EXPRESS WRITTEN CONSENT OF ASYNCHRON SYSTEMS INC.                *
*                                                                      *
* Create Date  Req#  Who  Description                                  *
* 10 JUL 2022  N/A   NT   Editor v2                                    *
*                                                                      *
************************************************************************
* Special Instructions                                                 *
*                                                                      *
************************************************************************
* Change History                                                       *
*                                                                      *
* Change Date  Req#  Who  Description                                  *
*                                                                      *
************************************************************************
*
    EXECUTE 'TERM xterm'
*
* VERSION
*
    VERSION = '1'
*
    EQU TRUE TO 1
    EQU FALSE TO 0
*
    EQU KEY.CTRL.A TO CHAR(1)
    EQU KEY.CTRL.C TO CHAR(3)
    EQU KEY.CTRL.F TO CHAR(6)
    EQU KEY.CTRL.Q TO CHAR(17)
    EQU KEY.CTRL.R TO CHAR(18)
    EQU KEY.CTRL.S TO CHAR(19)
    EQU KEY.CTRL.V TO CHAR(22)
    EQU KEY.CTRL.Z TO CHAR(26)
*
    EQU KEY.ESCAPE TO CHAR(27)
    EQU KEY.BACKSPACE TO CHAR(8)
    EQU KEY.TAB TO CHAR(9)
    EQU KEY.LINE.FEED TO CHAR(10)
    EQU KEY.CARRIAGE.RETURN TO CHAR(13)
    EQU KEY.DELETE TO CHAR(127)
*
    EQU KEY.EXCLAIMATION.MARK TO CHAR(33)
*
    EQU ESCAPE.CODE TO CHAR(27)
*
    BOTTOM = @(0,66)
    CLEAR.SCREEN = @(-1)
    CLEAR.REST.OF.SCREEN = @(-3)
    CLEAR.REST.OF.LINE = @(-4)
    CLEAR.LINE = @(0) : CLEAR.REST.OF.LINE
*
* ANSI 16 COLORS
*
    RESET.COLOR = ESCAPE.CODE : '[0m'
*
    BLACK = RESET.COLOR : ESCAPE.CODE : '[30m'
    RAW.BLACK = ESCAPE.CODE : '[30m'
    RED = RESET.COLOR : ESCAPE.CODE : '[31m'
    RAW.RED = ESCAPE.CODE : '[31m'
    GREEN = RESET.COLOR : ESCAPE.CODE : '[32m'
    YELLOW = RESET.COLOR : ESCAPE.CODE : '[33m'
    BLUE = RESET.COLOR : ESCAPE.CODE : '[34m'
    MAGENTA = RESET.COLOR : ESCAPE.CODE : '[35m'
    CYAN = RESET.COLOR : ESCAPE.CODE : '[36m'
    WHITE = RESET.COLOR : ESCAPE.CODE : '[37m'
    RAW.WHITE = ESCAPE.CODE : '[37m'
*
    BRIGHTBLACK = RESET.COLOR : ESCAPE.CODE : '[30;1m'
    BRIGHTRED = RESET.COLOR : ESCAPE.CODE : '[31;1m'
    BRIGHTGREEN = RESET.COLOR : ESCAPE.CODE : '[32;1m'
    BRIGHTYELLOW = RESET.COLOR : ESCAPE.CODE : '[33;1m'
    BRIGHTBLUE = RESET.COLOR : ESCAPE.CODE : '[34;1m'
    BRIGHTMAGENTA = RESET.COLOR : ESCAPE.CODE : '[35;1m'
    BRIGHTCYAN = RESET.COLOR : ESCAPE.CODE : '[36;1m'
    BRIGHTWHITE = RESET.COLOR : ESCAPE.CODE : '[37;1m'
*
    BACKGROUND.BLACK = RESET.COLOR : ESCAPE.CODE : '[40m'
    BACKGROUND.RED = RESET.COLOR : ESCAPE.CODE : '[41m'
    BACKGROUND.GREEN = RESET.COLOR : ESCAPE.CODE : '[42m'
    BACKGROUND.YELLOW = RESET.COLOR : ESCAPE.CODE : '[43m'
    BACKGROUND.BLUE = RESET.COLOR : ESCAPE.CODE : '[44m'
    BACKGROUND.MAGENTA = RESET.COLOR : ESCAPE.CODE : '[45m'
    BACKGROUND.CYAN = RESET.COLOR : ESCAPE.CODE : '[46m'
    BACKGROUND.WHITE = RESET.COLOR : ESCAPE.CODE : '[47m'
*
    BACKGROUND.BRIGHTBLACK = RESET.COLOR : ESCAPE.CODE : '[40;1m'
    BACKGROUND.BRIGHTRED = RESET.COLOR : ESCAPE.CODE : '[41;1m'
    BACKGROUND.BRIGHTGREEN = RESET.COLOR : ESCAPE.CODE : '[42;1m'
    BACKGROUND.BRIGHTYELLOW = RESET.COLOR : ESCAPE.CODE : '[43;1m'
    BACKGROUND.BRIGHTBLUE = RESET.COLOR : ESCAPE.CODE : '[44;1m'
    BACKGROUND.BRIGHTMAGENTA = RESET.COLOR : ESCAPE.CODE : '[45;1m'
    BACKGROUND.BRIGHTCYAN = RESET.COLOR : ESCAPE.CODE : '[46;1m'
    BACKGROUND.BRIGHTWHITE = RESET.COLOR : ESCAPE.CODE : '[47;1m'
*
    MESSAGE.COLOR = BRIGHTGREEN
    EDITOR.COLOR = BRIGHTWHITE
    HEADER.COLOR = BRIGHTGREEN
    FOREGROUND.COLOR = WHITE
*
    LINE.NUMBER.COLOR = BRIGHTBLACK
*
    COMMENT.COLOR = BRIGHTBLACK
    STMT.COLOR = GREEN
    FUNCTION.COLOR = MAGENTA
    OPERATOR.COLOR = RED
    SPECIAL.COLOR = YELLOW
    NUMBER.COLOR = YELLOW
*
    STRING.COLOR = CYAN
*
    @USER1 = 'VIM2'
    @USER2 = 'VIM2'
*
* TERMINAL INITIALIZATION
*
    EQU TERMINAL.TYPE.ATTRIBUTE TO 1
    EQU TERMINAL.UP.ATTRIBUTE TO 2
    EQU TERMINAL.DOWN.ATTRIBUTE TO 3
    EQU TERMINAL.LEFT.ATTRIBUTE TO 4
    EQU TERMINAL.RIGHT.ATTRIBUTE TO 5
*
    $IFDEF DATABASE.UV
        UP.ARROW = 'OA'
        DOWN.ARROW = 'OB'
        LEFT.ARROW = 'OD'
        RIGHT.ARROW = 'OC'
*
        PAGE.UP = '[5~'
        PAGE.DOWN = '[6~'
    $ENDIF
*
    $IFDEF DATABASE.D3
        UP.ARROW = '[A'
        DOWN.ARROW = '[B'
        LEFT.ARROW = '[D'
        RIGHT.ARROW = '[C'
*
        PAGE.UP = 'J'
        PAGE.DOWN = 'K'
    $ENDIF
*
    SCREEN.WIDTH = 132
    SCREEN.HEIGHT = 66
*
    MARGIN.TOP = 1
    MARGIN.BOTTOM = 1
    MARGIN.LEFT = 3
    MARGIN.RIGHT = 1
*
* SET VOC
*
    $IFDEF DATABASE.UV
        VOC = 'VOC'
    $ENDIF
    $IFDEF DATABASE.D3
        VOC = 'MD'
    $ENDIF
*
* FILE FOR SAVING HISTORY
*
    EQU EVA.SEARCH.ATTRIBUTE TO 1
    EQU EVA.EDITOR.ATTRIBUTE TO 2
    EQU EVA.YANKED.ATTRIBUTE TO 3
*
    EVA.HISTORY.OPENED = TRUE
    OPEN '','EVA-HISTORY-FILE' TO EVA.HISTORY.FILE ELSE
        OPEN '',VOC TO VOC.FILE THEN
            EVA.ENTRY = ''
            $IFDEF PLATFORM.LINUX
                $IFDEF DATABASE.UV
                    EVA.ENTRY<1> = 'F'
                    EVA.ENTRY<2> = '/tmp/.eva/'
                    EVA.ENTRY<3> = '/tmp/.eva/'
                $ENDIF
                $IFDEF DATABASE.D3
                    EVA.ENTRY<1> = 'Q'
                    EVA.ENTRY<3> = 'UNIX:/tmp/.eva/'
                $ENDIF
            $ENDIF
            $IFDEF PLATFORM.WINDOWS
                $IFDEF DATABASE.UV
                    EVA.ENTRY<1> = 'F'
                    EVA.ENTRY<2> = 'DOS:C:\.eva\'
                    EVA.ENTRY<3> = 'DOS:C:\.eva\'
                $ENDIF
                $IFDEF DATABASE.D3
                    EVA.ENTRY<1> = 'Q'
                    EVA.ENTRY<3> = 'DOS:C:\.eva\'
                $ENDIF
            $ENDIF
*
            WRITE EVA.ENTRY ON VOC.FILE,'EVA-HISTORY-FILE'
*
            OPEN '','EVA-HISTORY-FILE' TO EVA.HISTORY.FILE ELSE
                $IFDEF PLATFORM.LINUX
                    $IFDEF DATABASE.UV
                        EXECUTE 'SH -c "mkdir -p /tmp/.eva/"'
                    $ENDIF
                    $IFDEF DATABASE.D3
                        EXECUTE '!mkdir -p /tmp/.eva/'
                    $ENDIF
                $ENDIF
                $IFDEF PLATFORM.WINDOWS
                    EXECUTE '! mkdir C:\.eva'
                $ENDIF
                OPEN '','EVA-HISTORY-FILE' TO EVA.HISTORY.FILE ELSE
                    EVA.HISTORY.OPENED = FALSE
                END
            END
        END ELSE
            EVA.HISTORY.OPENED = FALSE
        END
    END
*
* SHELL INITIALIZATION
*
    $IFDEF DATABASE.UV
        USER.NAME = @ACCOUNT
        PORT.NUMBER = @USERNO
        ACCOUNT.NAME = @WHO
    $ENDIF
*
    $IFDEF DATABASE.D3
        USER.NAME = @USER
        PORT.NUMBER = @USERNO
        ACCOUNT.NAME = @ACCOUNT
    $ENDIF
*
* EVA USER SPECIFIC INITIALIZATION
*
    EVA.HISTORY.NAME = USER.NAME : '.eva_history'
*
    IF EVA.HISTORY.OPENED THEN
        READ EVA.HISTORY FROM EVA.HISTORY.FILE, EVA.HISTORY.NAME ELSE EVA.HISTORY = ''
*
        SEARCH.HISTORY = EVA.HISTORY<EVA.SEARCH.ATTRIBUTE>
        EDITOR.HISTORY = EVA.HISTORY<EVA.EDITOR.ATTRIBUTE>
        YANKED.LINES = EVA.HISTORY<EVA.YANKED.ATTRIBUTE>
        PASTE.NEWLINE = TRUE
*
    END ELSE
        SEARCH.HISTORY = ''
        EDITOR.HISTORY = ''
        YANKED.LINES = ''
        PASTE.NEWLINE = FALSE
    END
*
    COMMAND = SENTENCE()
*
    NUMBER.OF.ARGUMENTS = DCOUNT(COMMAND,' ')
*
    QUIT.ALL.FLAG = FALSE
    VIEW.NUMBERS = TRUE
*
    IF NUMBER.OF.ARGUMENTS = 2 THEN
        FILENAME = FIELD(COMMAND,' ',2)
        OPEN '',FILENAME TO FILE ELSE
            PRINT 'Unable to open file: ' : FILENAME : ' - Press RETURN':
            INPUT ANYTHING
            STOP
        END
*
        LOOP
            READNEXT RECORD.ID ELSE RECORD.ID = ''
        UNTIL RECORD.ID = '' DO
            PRINT RECORD.ID
            READU RAW.LINES FROM FILE,RECORD.ID LOCKED
                PRINT 'Record is locked: ' : RECORD.ID : ' - Press RETURN':
                INPUT ANYTHING :
            END ELSE RAW.LINES = ''
*
            GOSUB MAIN
*
            RELEASE FILE,RECORD.ID
*
            IF QUIT.ALL.FLAG THEN
                EXIT
            END
        REPEAT
*
    END ELSE IF NUMBER.OF.ARGUMENTS = 3 THEN
        FILENAME = FIELD(COMMAND,' ',2)
*
        OPEN '',FILENAME TO FILE ELSE
            PRINT 'Unable to open file: ' : FILENAME : ' - Press RETURN':
            INPUT ANYTHING
            STOP
        END
*
        RECORD.ID = FIELD(COMMAND,' ',3)
        GOSUB READ.RECORD
*
        GOSUB MAIN
*
    END ELSE IF NUMBER.OF.ARGUMENTS = 4 THEN
        FILENAME = FIELD(COMMAND,' ',3)
*
        OPEN 'DICT',FILENAME TO FILE ELSE
            PRINT 'Unable to open dict file: ' : FILENAME : ' - Press RETURN':
            INPUT ANYTHING
            STOP
        END
*
        RECORD.ID = FIELD(COMMAND,' ',4)
        GOSUB READ.RECORD
*
        GOSUB MAIN
*
    END ELSE
        PRINT 'Invalid number of arguments.'
        STOP
    END
*
    STOP
*
*********************  S U B R O U T I N E  *********************
*
READ.RECORD:NULL
*
    READU RAW.LINES FROM FILE,RECORD.ID LOCKED
        PRINT 'Record is locked: ' : RECORD.ID : ' - Press RETURN':
        INPUT ANYTHING
        STOP
    END ELSE RAW.LINES = ''
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
MAIN:NULL
*
    SEARCH.RESULTS = ''
    SEARCH.POSITION = 0
    ORIGINAL.SEARCH.STRING = ''
*
    SEARCH.STRING = SEARCH.HISTORY<1,DCOUNT(SEARCH.HISTORY<1>,@VM)>
    GOSUB PROCESS.SEARCH
*
    PRINT @(0,0) : CLEAR.REST.OF.SCREEN
*
    QUIT.FLAG = FALSE
*
    UP.ARROW.MODE = FALSE
*
    ORIGINAL.RAW.LINES = RAW.LINES
*
    NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
    IF NUMBER.OF.RAW.LINES = 0 THEN NUMBER.OF.RAW.LINES = 1
*
    IF VIEW.NUMBERS = FALSE THEN
        MARGIN.LEFT = 0
*
    END ELSE IF NUMBER.OF.RAW.LINES < 10 THEN
        PADDING.LEFT = 'R#2 '
        MARGIN.LEFT = 2 + 1
    END ELSE
        PADDING.LEFT = 'R#' : LEN(NUMBER.OF.RAW.LINES) : ' '
        MARGIN.LEFT = LEN(NUMBER.OF.RAW.LINES) + 1
    END
*
    OPEN '','MD' TO MD.FILE ELSE
        PRINT 'Unable to open file:  - Press RETURN':
        INPUT ANYTHING
        STOP
    END
*
* SET FILETYPE
*
    READ ANYTHING FROM MD.FILE,FILENAME:'.O' THEN
        FILETYPE = 'BASIC'
    END ELSE IF FILENAME = 'BP' OR FILENAME = 'MPROCLIB' THEN
        FILETYPE = 'BASIC'
    END ELSE IF RAW.LINES<1> = 'PQ' THEN
        FILETYPE = 'PROC'
    END ELSE
        FILETYPE = 'DATA'
    END
*
    ARCHIVE.FILENAME = 'ARCHIVE-' : FILENAME
    ARCHIVE.OPENED = FALSE
*
    OPEN '', ARCHIVE.FILENAME TO ARCHIVE.FILE THEN
        ARCHIVE.OPENED = TRUE
    END
*
* SETUP SYNTAX
*
    GOSUB SYNTAX.INIT
*
* VIEWPOINT SIZE
*
    VIEW.WIDTH = SCREEN.WIDTH - MARGIN.LEFT - MARGIN.RIGHT
    VIEW.HEIGHT = SCREEN.HEIGHT - MARGIN.TOP - MARGIN.BOTTOM
*
    TAB.SIZE = 4
    ORIGINAL.X.POS = 0
    ERROR.MESSAGE = ''
*
    EDITOR.PROMPT = ':'
    SEARCH.PROMPT = '/'
*
    EDITOR.MARGIN.LEFT = LEN(EDITOR.PROMPT)
    SEARCH.MARGIN.LEFT = LEN(SEARCH.PROMPT)
*
    LINE.START = 1
    CURRENT.LINE = 1
    BLOCK.START = 1
    BLOCK.END = 1
*
* STACK INITIALIZATION
*
    INSIDE.VLIST = FALSE
*
    ORIGINAL.RAW.LINES.STACK = ''
    RAW.LINES.STACK = ''
    REAL.LINE.NUMBER.STACK = ''
    HISTORY.STACK = ''
    HISTORY.X.Y.STACK = ''
    HISTORY.POS.STACK = ''
    LINE.START.STACK = ''
    NEST.LEVEL = 0
*
    PAGE.HEIGHT = VIEW.HEIGHT
*
    GOSUB PUT.CURSOR.TOP.LEFT
*
    GOSUB CONVERT.RAW.LINES
    GOSUB DISPLAY.LINES
    GOSUB PUT.CURSOR.TOP.LEFT
*
    INPUT.AVAILABLE = FALSE
    PROCESS.CHAR = ''
*
    EDITOR.COMMAND.AVAILABLE = FALSE
    EDITOR.COMMAND = ''
*
    HISTORY = ''
    HISTORY.X.Y = ''
    HISTORY.POS = 1
*
* CC.LIST INIT
*
    CC.BREAK.CHARACTERS = '( ) , : + - / ; * < > = [ ]' : ' "' : " '"
    CONVERT ' ' TO @AM IN CC.BREAK.CHARACTERS
    CC.BREAK.CHARACTERS = CC.BREAK.CHARACTERS : @AM : ' '
*
    CC.LIST.OPEN = FALSE
    SNIPPETS = ''
    SNIPPET.HEADERS = ''
*
    GOSUB ADD.DEFAULT.SNIPPETS
*
    PATH = '/home/usr/nivethan/.vim/UltiSnips/all.snippets'
    GOSUB ADD.SNIPPETS
*
    IF DCOUNT(RAW.LINES,@AM) < 3000 THEN
        GOSUB ADD.AUTO.COMPLETE
    END
*
    LINE.TO.MAX = 0
*
    LOOP WHILE TRUE DO
        IF INPUT.AVAILABLE THEN
            CHR = PROCESS.CHAR
            INPUT.AVAILABLE = FALSE
        END ELSE
            $IFDEF DATABASE.UV
                CHR = KEYIN()
            $ENDIF
            $IFDEF DATABASE.D3
                INPUT CHR,0
            $ENDIF
        END
*
        ASCII.CODE = SEQ(CHR)
        GOSUB PRINT.CURRENT.LINE
*
        IF ASCII.CODE = SEQ(KEY.ESCAPE) THEN
            GOSUB PROCESS.ESCAPE.KEY
            GOSUB PROCESS.BASE.ESCAPE.KEY
*
        END ELSE IF ASCII.CODE = SEQ(KEY.BACKSPACE) THEN
            IF X.POS > MARGIN.LEFT THEN
                ORIGINAL.X.POS = 0
                X.POS = X.POS - 1
                GOSUB DISPLAY.HEADER
                PRINT @(X.POS, Y.POS) :
            END
*
        END ELSE IF ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) THEN
            GOSUB SCROLL.DOWN
*
        END ELSE IF CHR = ':' THEN
            GOSUB PROCESS.EDITOR.COMMAND
*
        END ELSE IF CHR = 'h' THEN
            GOSUB PRINT.CURRENT.LINE
            GOSUB SCROLL.LEFT
            PRINT @(X.POS, Y.POS) :
*
        END ELSE IF CHR = 'l' THEN
            GOSUB PRINT.CURRENT.LINE
            GOSUB SCROLL.RIGHT
            PRINT @(X.POS, Y.POS) :
*
        END ELSE IF CHR = 'j' THEN
            GOSUB SCROLL.DOWN
*
        END ELSE IF CHR = 'k' THEN
            GOSUB SCROLL.UP
*
        END ELSE IF CHR = 'c' THEN
            REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
            RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
            IF RAW.LINE[1,6] = '*TEMP ' THEN
                RAW.LINE = CHANGE(RAW.LINE,'*TEMP ','',1)
            END ELSE
                RAW.LINE = '*TEMP ' : RAW.LINE
            END
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
            GOSUB UPDATE.LINE
            GOSUB DISPLAY.LINES
*
            PRINT @(X.POS,Y.POS) :
*
        END ELSE IF CHR = 'e' THEN
            INSERT.LINE = '*'
            GOSUB PROCESS.INSERT.LINE
*
            GOSUB DISPLAY.LINES
            PRINT @(X.POS,Y.POS) :
*
        END ELSE IF CHR = 'd' THEN
            GOSUB PROCESS.DELETE.LINE
*
        END ELSE IF CHR = 'o' THEN
            INSERT.LINE = ''
            GOSUB PROCESS.INSERT.LINE
*
            GOSUB DISPLAY.LINES
            PRINT @(X.POS,Y.POS) :
*
            PROCESS.CHAR = 'i'
            INPUT.AVAILABLE = TRUE
*
        END ELSE IF CHR = 'x' THEN
            GOSUB PROCESS.DELETE.CHARACTER
*
        END ELSE IF CHR = 'r' THEN
            GOSUB PROCESS.REPLACE.CHARACTER
*
        END ELSE IF CHR = 'u' OR ASCII.CODE = SEQ(KEY.CTRL.Z) THEN
            GOSUB UNDO.HISTORY
*
        END ELSE IF ASCII.CODE = SEQ(KEY.CTRL.R) THEN
            GOSUB REDO.HISTORY
*
        END ELSE IF CHR = 'v' THEN
            ORIGINAL.X.POS = X.POS
            START.COPY.POS = X.POS - MARGIN.LEFT
            HIGHLIGHTED.CHARS = 1
*
            LINE = LINES<CURRENT.LINE>
            LINE.LEN = LEN(LINE)
*
            LINE = LINE[1,START.COPY.POS] : BACKGROUND.CYAN : LINE[START.COPY.POS+1,HIGHLIGHTED.CHARS] : RESET.COLOR : LINE[START.COPY.POS+HIGHLIGHTED.CHARS+1,9999]
            PRINT @(MARGIN.LEFT,Y.POS) : LINE
            PRINT @(X.POS,Y.POS) :
*
            LOOP WHILE TRUE DO
                
                $IFDEF DATABASE.UV
                    CHR = KEYIN()
                $ENDIF
                $IFDEF DATABASE.D3
                    INPUT CHR,0
                $ENDIF
*
                ASCII.CODE = SEQ(CHR)
*
                IF ASCII.CODE = SEQ(KEY.ESCAPE) THEN
                    GOSUB PROCESS.ESCAPE.KEY
                    IF ESCAPE.SEQUENCE = LEFT.ARROW THEN
                        IF X.POS > ORIGINAL.X.POS THEN
                            X.POS = X.POS - 1
                            HIGHLIGHTED.CHARS = HIGHLIGHTED.CHARS - 1
                        END
                    END ELSE IF ESCAPE.SEQUENCE = RIGHT.ARROW THEN
                        IF X.POS < LINE.LEN + MARGIN.LEFT - 1 THEN
                            X.POS = X.POS + 1
                            HIGHLIGHTED.CHARS = HIGHLIGHTED.CHARS + 1
                        END
                    END
*
                    GOSUB PRINT.CURRENT.LINE
*
                    LINE = LINES<CURRENT.LINE>
                    LINE = LINE[1,START.COPY.POS] : BACKGROUND.CYAN : LINE[START.COPY.POS+1,HIGHLIGHTED.CHARS] : RESET.COLOR : LINE[START.COPY.POS+HIGHLIGHTED.CHARS+1,9999]
                    PRINT @(MARGIN.LEFT,Y.POS) : LINE
                    PRINT @(X.POS,Y.POS) :
*
                END ELSE
                    EXIT
                END
            REPEAT
*
            PASTE.NEWLINE = FALSE
            YANKED.LINES = LINES<CURRENT.LINE>[START.COPY.POS+1,HIGHLIGHTED.CHARS]
            IF EVA.HISTORY.OPENED THEN WRITEV YANKED.LINES ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.YANKED.ATTRIBUTE
*
            GOSUB PRINT.CURRENT.LINE
            PRINT @(X.POS,Y.POS) :
*
            X.POS = ORIGINAL.X.POS
            PRINT @(X.POS,Y.POS) :
*
        END ELSE IF CHR = 'y' THEN
            PASTE.NEWLINE = TRUE
            REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
            YANKED.LINES = RAW.LINES<REAL.LINE.NUMBER>
            IF EVA.HISTORY.OPENED THEN WRITEV YANKED.LINES ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.YANKED.ATTRIBUTE
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Copied line ' : CURRENT.LINE : '.' :
            PRINT @(X.POS,Y.POS) :
*
        END ELSE IF CHR = 'p' THEN
            GOSUB PUSH.HISTORY
*
            IF PASTE.NEWLINE THEN
                NUMBER.OF.YANKED.LINES = DCOUNT(YANKED.LINES,@VM)
*
                FOR PASTE.CTR = 1 TO NUMBER.OF.YANKED.LINES
                    INSERT.LINE = YANKED.LINES<1,PASTE.CTR>
                    GOSUB PROCESS.INSERT.LINE
                NEXT PASTE.CTR
*
                GOSUB DISPLAY.LINES
                PRINT @(X.POS,Y.POS) :
*
            END ELSE
                REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
                GOSUB GET.INSERT.CHAR.POS
*
                RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
                RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION+1] : YANKED.LINES : RAW.LINE[INSERT.CHAR.POSITION+2,9999]
                RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
                GOSUB UPDATE.LINE
                GOSUB DISPLAY.LINES
*
                PRINT @(X.POS,Y.POS) :
            END
*
        END ELSE IF CHR = '/' OR ASCII.CODE = SEQ(KEY.CTRL.F) THEN
            GOSUB PROCESS.SEARCH.INPUT
            GOSUB PROCESS.SEARCH
            SEARCH.POSITION = SEARCH.POSITION + 1
            GOSUB GOTO.SEARCH.RESULT
*
        END ELSE IF CHR = 'n' THEN
            GOSUB PROCESS.SEARCH
            IF SEARCH.RESULTS # '' THEN
                IF SEARCH.POSITION = DCOUNT(SEARCH.RESULTS,@AM) THEN
                    SEARCH.POSITION = 0
                    PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
                    PRINT 'Search hit the bottom, starting from top.' :
                END
                SEARCH.POSITION = SEARCH.POSITION + 1
                GOSUB GOTO.SEARCH.RESULT
            END
*
        END ELSE IF CHR = 'N' THEN
            GOSUB PROCESS.SEARCH
            IF SEARCH.RESULTS # '' THEN
                IF SEARCH.POSITION = 1 THEN
                    SEARCH.POSITION = DCOUNT(SEARCH.RESULTS,@AM) + 1
                    PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
                    PRINT 'Search hit the top, starting from bottom.' :
                END
                SEARCH.POSITION = SEARCH.POSITION - 1
                GOSUB GOTO.SEARCH.RESULT
            END
*
        END ELSE IF CHR = '$' THEN
            LINE.LEN = LEN(LINES<CURRENT.LINE>)
            X.POS = MARGIN.LEFT + LINE.LEN - 1
            PRINT @(X.POS,Y.POS) :
*
        END ELSE IF CHR = '0' THEN
            X.POS = MARGIN.LEFT
            PRINT @(X.POS,Y.POS) :
*
        END ELSE IF CHR = '<' THEN
            BLOCK.START = LINE.NUMBERS<CURRENT.LINE>
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Block started from line ' : BLOCK.START : '.' :
            PRINT @(X.POS,Y.POS) :
*
        END ELSE IF CHR = '>' THEN
            BLOCK.END = LINE.NUMBERS<CURRENT.LINE>
*
            IF BLOCK.END < BLOCK.START THEN
                PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
                PRINT 'Cannot copy from ' : BLOCK.START : ' to ' : BLOCK.END : '.' :
                PRINT @(X.POS,Y.POS) :
                CONTINUE
            END
*
            IF BLOCK.END > DCOUNT(RAW.LINES,@AM) THEN
                BLOCK.END = DCOUNT(RAW.LINES,@AM)
            END
*
            PASTE.NEWLINE = TRUE
            YANKED.LINES = ''
            FOR BLOCK.CTR = BLOCK.START TO BLOCK.END
                YANKED.LINES<1,-1> = RAW.LINES<BLOCK.CTR>
            NEXT BLOCK.CTR
            IF EVA.HISTORY.OPENED THEN WRITEV YANKED.LINES ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.YANKED.ATTRIBUTE
*
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Copied ' : BLOCK.END - BLOCK.START : ' lines from ' : BLOCK.START : ' to ' : BLOCK.END : '.' :
            PRINT @(X.POS,Y.POS) :
*
        END ELSE IF CHR = 'i' THEN
            GOSUB PROCESS.INSERT
*
        END ELSE IF CHR = 'G' THEN
            GOTO.LINE = DCOUNT(RAW.LINES,@AM)
            GOSUB GOTO.LINE.POSITION
*
            X.POS = MARGIN.LEFT
            PRINT @(X.POS,Y.POS) :
*
        END ELSE
            PRINT @(X.POS,Y.POS) :
        END
*
        IF QUIT.FLAG THEN
            EXIT
        END
    REPEAT
*
    RETURN
*
*********************  s u b r o u t i n e  *********************
*
SYNTAX.INIT:NULL
*
    IF FILETYPE = 'BASIC' THEN
        GOSUB SYNTAX.INIT.BASIC
    END ELSE IF FILETYPE = 'PROC' THEN
        GOSUB SYNTAX.INIT.PROC
    END ELSE IF FILETYPE = 'DATA' THEN
    END
*
    RETURN
*
*********************  s u b r o u t i n e  *********************
*
SYNTAX.INIT.BASIC:NULL
*
    STATEMENTS = ''
    STATEMENTS = STATEMENTS : ' ' : '$DEFINE $IFDEF $ENDIF ABORT ACTIVATEKEY AUTHORIZATION AUXMAP'
    STATEMENTS = STATEMENTS : ' ' : 'BEGIN BREAK BSCAN'
    STATEMENTS = STATEMENTS : ' ' : 'CALL CALLING CAPTURING CASE CHAIN CLEAR CLEARDATA CLEARFILE CLEARPROMPTS CLEARSELECT CLOSE'
    STATEMENTS = STATEMENTS : ' ' : 'CLOSESEQ COMMIT COMMON CONTINUE CREATE CRT'
    STATEMENTS = STATEMENTS : ' ' : 'DATA DEACTIVATEKEY DEBUG DEFFUN DELETE DELETELIST DELETEU DIM DIMENSION DISABLEDEC DISPLAY'
    STATEMENTS = STATEMENTS : ' ' : 'EQU ECHO ELSE ENABLEDEC END ENTER EOF EQUATE ERRMSG ERROR EXECUTE EXIT'
    STATEMENTS = STATEMENTS : ' ' : 'FILELOCK FILEUNLOCK FIND FINDSTR FLUSH FOOTING FOR FROM FUNCTION'
    STATEMENTS = STATEMENTS : ' ' : 'GET GETLIST GETX GOSUB GOTO GROUPSTORE'
    STATEMENTS = STATEMENTS : ' ' : 'HEADING HUSH'
    STATEMENTS = STATEMENTS : ' ' : 'IF INCLUDE INPUT INPUTCLEAR INPUTDISP INPUTDP INPUTERR INPUTNULL INPUTTRAP INS ISOLATION'
    STATEMENTS = STATEMENTS : ' ' : 'KEYEDIT KEYEXIT KEYTRAP'
    STATEMENTS = STATEMENTS : ' ' : 'LET LEVEL LOCATE LOCK LOOP'
    STATEMENTS = STATEMENTS : ' ' : 'MAT MATBUILD MATPARSE MATREAD MATREADL MATREADU MATWRITE MATWRITEU'
    STATEMENTS = STATEMENTS : ' ' : 'NAP NEXT NOBUF NOW'
    STATEMENTS = STATEMENTS : ' ' : 'OFF ON OPEN OPENDEV OPENPATH OPENSEQ'
    STATEMENTS = STATEMENTS : ' ' : 'PAGE PERFORM PRECISION PRINT PRINTER PRINTERR PROCREAD PROCWRITE PROGRAM PROMPT '
    STATEMENTS = STATEMENTS : ' ' : 'RANDOMIZE READ READBLK READL READLIST READNEXT READSEQ READT READU READV READVL READVU RELEASE'
    STATEMENTS = STATEMENTS : ' ' : 'REPEAT RESET RETURN RETURNING REVREMOVE REWIND ROLLBACK'
    STATEMENTS = STATEMENTS : ' ' : 'SELECT SELECTE SELECTINDEX SELECTINFO SEND SET SETREM SLEEP SSELECT START STOP SUBROUTINE'
    STATEMENTS = STATEMENTS : ' ' : 'TABSTOP THEN TIMEOUT TO TPRINT TRANSACTION TTYCTL TTYGET TTYSET'
    STATEMENTS = STATEMENTS : ' ' : 'UNLOCK UNTIL UPRINT'
    STATEMENTS = STATEMENTS : ' ' : 'WEOF WEOFSEQ WHILE WRITE WRITEBLK WRITELIST WRITESEQ WRITESEQF WRITET WRITEU WRITEV WRITEVU'
*
    CONVERT ' ' TO @AM IN STATEMENTS
*
    FUNCTIONS = ''
    FUNCTIONS = FUNCTIONS : ' ' : 'ABS ABSS ACOS ADDS ALPHA ANDS ASCII ASIN ASSIGNED ATAN'
    FUNCTIONS = FUNCTIONS : ' ' : 'BITAND BITNOT BITOR BITRESET BITSET BITTEST BITXOR BYTE BYTELEN BYTETYPE BYTEVAL'
    FUNCTIONS = FUNCTIONS : ' ' : 'CATS CHANGE CHAR CHARS CHECKSUM COL1 COL2 COMPARE CONVERT COS COSH COUNT COUNTS'
    FUNCTIONS = FUNCTIONS : ' ' : 'DATE DCOUNT DEL DIV DIVS DOWNCASE DQUOTE DTX'
    FUNCTIONS = FUNCTIONS : ' ' : 'EBCDIC EQS EREPLACE EXCHANGE EXP EXTRACT'
    FUNCTIONS = FUNCTIONS : ' ' : 'FADD FDIV FFIX FFLT FIELD FIELDS FIELDSTORE FILEINFO FIX FMT FMTDP FMTS FMTSDP FMUL FOLD FOLDDP FSUB'
    FUNCTIONS = FUNCTIONS : ' ' : 'GES GETLOCALE GETREM GROUP GTS'
    FUNCTIONS = FUNCTIONS : ' ' : 'ICONV ICONVS IFS ILPROMPT INDEX INDEXS INDICES INMAT INSERT INT ISNULL ISNULLS ITYPE'
    FUNCTIONS = FUNCTIONS : ' ' : 'KEYIN'
    FUNCTIONS = FUNCTIONS : ' ' : 'LEFT LEN LENDP LENS LENSDP LES LEVEL LN LOCALEINFO LOWER LTS'
    FUNCTIONS = FUNCTIONS : ' ' : 'MATCHFIELD MAXIMUM MINIMUM MOD MODS MULS'
    FUNCTIONS = FUNCTIONS : ' ' : 'NEG NEGS NES NOT NOTS NUM NUMS'
    FUNCTIONS = FUNCTIONS : ' ' : 'OCONV OCONVS ORS'
    FUNCTIONS = FUNCTIONS : ' ' : 'PWR'
    FUNCTIONS = FUNCTIONS : ' ' : 'QUOTE'
    FUNCTIONS = FUNCTIONS : ' ' : 'RAISE REAL RECORDLOCKED RECORDLOCKL RECORDLOCKU REMOVE REPLACE REUSE '
    FUNCTIONS = FUNCTIONS : ' ' : 'RIGHT RND RPC.CALL RPC.CONNECT RPC.DISCONNECT'
    FUNCTIONS = FUNCTIONS : ' ' : 'SADD SCMP SDIV SEEK SENTENCE SEQ SEQS SETLOCALE SIN SINH SMUL SOUNDEX SPACE SPACES SPLICE SQRT'
    FUNCTIONS = FUNCTIONS : ' ' : 'SQUOTE SSUB START STR STRS SUBR SUBS SUBSTRINGS SUM SUMMATION SYSTEM'
    FUNCTIONS = FUNCTIONS : ' ' : 'TAN TANH TERMINFO TIME TIMEDATE TPARM TRANS TRIM TRIMB TRIMBS TRIMF TRIMFS TRIMS'
    FUNCTIONS = FUNCTIONS : ' ' : 'UNASSIGNED UNICHAR UNICHARS UNISEQ UNISEQS UPCASE'
    FUNCTIONS = FUNCTIONS : ' ' : 'XLATE XTD'
    FUNCTIONS = FUNCTIONS : ' ' : 'amInitialize amReceiveMsg amReceiveRequest amSendMsg amSendRequest amSendResponse amTerminate'
*
    CONVERT ' ' TO @AM IN FUNCTIONS
*
    OPERATORS = ''
    OPERATORS = OPERATORS : ' ' : '+'
    OPERATORS = OPERATORS : ' ' : '*'
    OPERATORS = OPERATORS : ' ' : '/'
    OPERATORS = OPERATORS : ' ' : '-'
    OPERATORS = OPERATORS : ' ' : '='
    OPERATORS = OPERATORS : ' ' : ':'
    OPERATORS = OPERATORS : ' ' : '<>'
    OPERATORS = OPERATORS : ' ' : '#'
    OPERATORS = OPERATORS : ' ' : '<'
    OPERATORS = OPERATORS : ' ' : '>'
    OPERATORS = OPERATORS : ' ' : '>='
    OPERATORS = OPERATORS : ' ' : '<='
    OPERATORS = OPERATORS : ' ' : ':='
    OPERATORS = OPERATORS : ' ' : '+='
    OPERATORS = OPERATORS : ' ' : 'AND OR'
*
    CONVERT ' ' TO @AM IN OPERATORS
*
    SPECIALS = ''
    SPECIALS = SPECIALS : ' ' : '@DATE'
    SPECIALS = SPECIALS : ' ' : '@FM'
    SPECIALS = SPECIALS : ' ' : '@VM'
    SPECIALS = SPECIALS : ' ' : '@SVM'
    SPECIALS = SPECIALS : ' ' : '@TM'
    SPECIALS = SPECIALS : ' ' : '@STM'
    SPECIALS = SPECIALS : ' ' : '@AM'
    SPECIALS = SPECIALS : ' ' : '@NULL'
    SPECIALS = SPECIALS : ' ' : '@COMMAND'
    SPECIALS = SPECIALS : ' ' : '@ID'
    SPECIALS = SPECIALS : ' ' : '@OPTION'
    SPECIALS = SPECIALS : ' ' : '@RECORD'
    SPECIALS = SPECIALS : ' ' : '@SENTENCE'
    SPECIALS = SPECIALS : ' ' : '@SELECTED'
    SPECIALS = SPECIALS : ' ' : '@TTY'
*
    CONVERT ' ' TO @AM IN SPECIALS
*
    BREAK.CHARACTERS = '( ) , : + - / ; * < > #'
    CONVERT ' ' TO @AM IN BREAK.CHARACTERS
*
    RETURN
*
*********************  s u b r o u t i n e  *********************
*
SYNTAX.INIT.PROC:NULL
*
    STATEMENTS = 'IF GO'
    CONVERT ' ' TO @AM IN STATEMENTS
*
    FUNCTIONS = ''
    CONVERT ' ' TO @AM IN FUNCTIONS
*
    OPERATORS = '< = > >= <= ( ) #'
    CONVERT ' ' TO @AM IN OPERATORS
*
    SPECIALS = ''
    CONVERT ' ' TO @AM IN SPECIALS
*
    BREAK.CHARACTERS = '( ) , : + - / ; * < > #'
    CONVERT ' ' TO @AM IN BREAK.CHARACTERS
*
    RETURN
*
*********************  s u b r o u t i n e  *********************
*
PUSH.HISTORY:NULL
*
    NUMBER.OF.HISTORY = DCOUNT(HISTORY,@AM)
*
    FOR HIST.CTR = HISTORY.POS TO NUMBER.OF.HISTORY
        HISTORY = DELETE(HISTORY,HIST.CTR)
        HISTORY.X.Y = DELETE(HISTORY.X.Y,HIST.CTR)
    NEXT HIST.CTR
*
    $IFDEF DATABASE.UV
        LOWERED.RECORD = LOWER(RAW.LINES)
    $ENDIF
*
    $IFDEF DATABASE.D3
        LOWERED.RECORD = RAW.LINES
        CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
    $ENDIF
*
    HISTORY<HISTORY.POS> = LOWERED.RECORD
*
    HISTORY.X.Y<HISTORY.POS,1> = X.POS
    HISTORY.X.Y<HISTORY.POS,2> = Y.POS
    HISTORY.X.Y<HISTORY.POS,3> = CURRENT.LINE
    HISTORY.X.Y<HISTORY.POS,4> = LINE.START
*
    HISTORY.POS = HISTORY.POS + 1
*
    RETURN
*
*********************  s u b r o u t i n e  *********************
*
UNDO.HISTORY:NULL
*
    IF HISTORY.POS = 1 THEN
        PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
        PRINT 'Already at the earliest change.' :
*
    END ELSE
        IF HISTORY.POS-1 >= DCOUNT(HISTORY,@AM) THEN
            $IFDEF DATABASE.UV
                LOWERED.RECORD = LOWER(RAW.LINES)
            $ENDIF
*
            $IFDEF DATABASE.D3
                LOWERED.RECORD = RAW.LINES
                CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
            $ENDIF
*
            HISTORY<HISTORY.POS> = LOWERED.RECORD
*
            HISTORY.X.Y<HISTORY.POS,1> = X.POS
            HISTORY.X.Y<HISTORY.POS,2> = Y.POS
            HISTORY.X.Y<HISTORY.POS,4> = LINE.START
        END
*
        HISTORY.POS = HISTORY.POS - 1
*
        $IFDEF DATABASE.UV
            RAISED.RECORD = RAISE(HISTORY<HISTORY.POS>)
        $ENDIF
        $IFDEF DATABASE.D3
            RAISED.RECORD = HISTORY<HISTORY.POS>
            CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
        $ENDIF
*
        RAW.LINES = RAISED.RECORD
        X.POS = HISTORY.X.Y<HISTORY.POS,1>
        Y.POS = HISTORY.X.Y<HISTORY.POS,2>
        CURRENT.LINE = HISTORY.X.Y<HISTORY.POS,3>
        LINE.START = HISTORY.X.Y<HISTORY.POS,4>
*
        GOSUB CONVERT.RAW.LINES
        GOSUB DISPLAY.LINES
*
        PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
        PRINT 'Rolled back 1 change. (' : HISTORY.POS : '/' : DCOUNT(HISTORY,@AM) : ')' :
    END
*
    PRINT @(X.POS,Y.POS) :
    RETURN
*
*********************  s u b r o u t i n e  *********************
*
REDO.HISTORY:NULL
*
    IF HISTORY.POS >= DCOUNT(HISTORY,@AM) THEN
        PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
        PRINT 'Already at the latest change.' :
*
    END ELSE
        HISTORY.POS = HISTORY.POS + 1
*
        $IFDEF DATABASE.UV
            RAISED.RECORD = RAISE(HISTORY<HISTORY.POS>)
        $ENDIF
        $IFDEF DATABASE.D3
            RAISED.RECORD = HISTORY<HISTORY.POS>
            CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
        $ENDIF
*
        RAW.LINES = RAISED.RECORD
        X.POS = HISTORY.X.Y<HISTORY.POS,1>
        Y.POS = HISTORY.X.Y<HISTORY.POS,2>
        CURRENT.LINE = HISTORY.X.Y<HISTORY.POS,3>
        LINE.START = HISTORY.X.Y<HISTORY.POS,4>
*
        GOSUB CONVERT.RAW.LINES
        GOSUB DISPLAY.LINES
*
        PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
        PRINT 'Rolled forward 1 change. (' : HISTORY.POS : '/' : DCOUNT(HISTORY,@AM) : ')' :
    END
*
    PRINT @(X.POS,Y.POS) :
*
    RETURN
*
*
*********************  s u b r o u t i n e  *********************
*
PUSH.EXPLODE:NULL
*
    IF INSIDE.VLIST THEN RETURN
*
    NEST.LEVEL = NEST.LEVEL + 1
*
    $IFDEF DATABASE.UV
        ORIGINAL.RAW.LINES.STACK<NEST.LEVEL> = LOWER(ORIGINAL.RAW.LINES)
        RAW.LINES.STACK<NEST.LEVEL> = LOWER(RAW.LINES)
*
        REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
        REAL.LINE.NUMBER.STACK<NEST.LEVEL> = REAL.LINE.NUMBER
*
        HISTORY.STACK<NEST.LEVEL> = LOWER(HISTORY)
        HISTORY.X.Y.STACK<NEST.LEVEL> = LOWER(HISTORY.X.Y)
        HISTORY.POS.STACK<NEST.LEVEL> = HISTORY.POS
*
        LINE.START.STACK<NEST.LEVEL> = LINE.START
    $ENDIF
*
    $IFDEF DATABASE.D3
        LOWERED.RECORD = ORIGINAL.RAW.LINES
        CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
        ORIGINAL.RAW.LINES.STACK<NEST.LEVEL> = LOWERED.RECORD
*
        LOWERED.RECORD = RAW.LINES
        CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
        RAW.LINES.STACK<NEST.LEVEL> = LOWERED.RECORD
*
        REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
        REAL.LINE.NUMBER.STACK<NEST.LEVEL> = REAL.LINE.NUMBER
*
        LOWERED.RECORD = HISTORY
        CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
        HISTORY.STACK<NEST.LEVEL> = LOWERED.RECORD
*
        LOWERED.RECORD = HISTORY.X.Y
        CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
        HISTORY.X.Y.STACK<NEST.LEVEL> = LOWERED.RECORD
*
        HISTORY.POS.STACK<NEST.LEVEL> = HISTORY.POS
*
        LINE.START.STACK<NEST.LEVEL> = LINE.START
*
    $ENDIF
*
    RETURN
*
*********************  s u b r o u t i n e  *********************
*
POP.EXPLODE:NULL
*
    $IFDEF DATABASE.UV
        LOWERED.RECORD = LOWER(RAW.LINES)
    $ENDIF
*
    $IFDEF DATABASE.D3
        LOWERED.RECORD = RAW.LINES
        CONVERT @AM:@VM:@SVM:@TM TO @VM:@SVM:@TM:@STM IN LOWERED.RECORD
    $ENDIF
*
    ROW = LOWERED.RECORD
*
    $IFDEF DATABASE.UV
        RAISED.RECORD = RAISE(RAW.LINES.STACK<NEST.LEVEL>)
    $ENDIF
    $IFDEF DATABASE.D3
        RAISED.RECORD = RAW.LINES.STACK<NEST.LEVEL>
        CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
    $ENDIF
*
    RAW.LINES = RAISED.RECORD
*
    REAL.LINE.NUMBER = REAL.LINE.NUMBER.STACK<NEST.LEVEL>
*
    IF SAVE.ROW THEN
        RAW.LINES<REAL.LINE.NUMBER> = ROW
    END
*
    $IFDEF DATABASE.UV
        RAISED.RECORD = RAISE(ORIGINAL.RAW.LINES.STACK<NEST.LEVEL>)
    $ENDIF
    $IFDEF DATABASE.D3
        RAISED.RECORD = ORIGINAL.RAW.LINES.STACK<NEST.LEVEL>
        CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
    $ENDIF
*
    ORIGINAL.RAW.LINES = RAISED.RECORD
*
    $IFDEF DATABASE.UV
        RAISED.RECORD = RAISE(HISTORY.STACK<NEST.LEVEL>)
    $ENDIF
    $IFDEF DATABASE.D3
        RAISED.RECORD =HISTORY.STACK<NEST.LEVEL>
        CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
    $ENDIF
*
    HISTORY = RAISED.RECORD
*
    $IFDEF DATABASE.UV
        RAISED.RECORD = RAISE(HISTORY.X.Y.STACK<NEST.LEVEL>)
    $ENDIF
    $IFDEF DATABASE.D3
        RAISED.RECORD = HISTORY.X.Y.STACK<NEST.LEVEL>
        CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
    $ENDIF
*
    HISTORY.X.Y = RAISED.RECORD
*
    HISTORY.POS = HISTORY.POS.STACK<NEST.LEVEL>
    LINE.START = LINE.START.STACK<NEST.LEVEL>
*
    RAW.LINES.STACK<NEST.LEVEL> = ''
    REAL.LINE.NUMBER.STACK<NEST.LEVEL> = ''
    ORIGINAL.RAW.LINES.STACK<NEST.LEVEL> = ''
    HISTORY.STACK<NEST.LEVEL> = ''
    HISTORY.X.Y.STACK<NEST.LEVEL> = ''
    HISTORY.POS.STACK<NEST.LEVEL> = ''
    LINE.START.STACK<NEST.LEVEL> = ''
*
    GOSUB CONVERT.RAW.LINES
    GOSUB DISPLAY.LINES
    GOSUB PUT.CURSOR.TOP.LEFT
*
    GOTO.LINE = REAL.LINE.NUMBER
    GOSUB GOTO.LINE.POSITION
*
    NEST.LEVEL = NEST.LEVEL - 1
*
    IF INSIDE.VLIST THEN
        INSIDE.VLIST = FALSE
    END
*
    PRINT @(X.POS,Y.POS) :
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PRINT.ERROR.MESSAGE:NULL
*
    PRINT BOTTOM : CLEAR.REST.OF.LINE :
    PRINT BRIGHTRED : 'E -> ' :
    PRINT ERROR.MESSAGE :
    PRINT @(X.POS, Y.POS) :
    INPUT ANYTHING :
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PUT.CURSOR.TOP.LEFT:NULL
*
* PLACE CURSOR IN TOP LEFT
*
    X.POS = MARGIN.LEFT
    Y.POS = MARGIN.TOP
    PRINT @(X.POS, Y.POS) :
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
SET.X.POS:NULL
*
    IF ORIGINAL.X.POS # 0 THEN
        X.POS = ORIGINAL.X.POS
        ORIGINAL.X.POS = 0
    END
*
    LINE.LEN = LEN(LINES<CURRENT.LINE>)
    IF LINE.LEN = 0 THEN LINE.LEN = 1
*
    IF X.POS >= LINE.LEN + MARGIN.LEFT THEN
        ORIGINAL.X.POS = X.POS
        X.POS = LINE.LEN + MARGIN.LEFT - 1
    END
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
GOTO.LINE.POSITION:NULL
*
    LOCATE(GOTO.LINE,LINE.NUMBERS;CURRENT.LINE) ELSE CURRENT.LINE = NUMBER.OF.LINES
*
    IF CURRENT.LINE > LINE.END OR CURRENT.LINE < LINE.START THEN
        LINE.START = CURRENT.LINE - 15
        IF LINE.START < 1 THEN LINE.START = 1
        GOSUB DISPLAY.LINES
    END
*
    Y.POS = CURRENT.LINE - LINE.START + MARGIN.TOP
*
    GOSUB DISPLAY.HEADER
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
GOTO.VISIBLE.LINE.POSITION:NULL
*
    IF CURRENT.LINE > LINE.END OR CURRENT.LINE < LINE.START THEN
        LINE.START = CURRENT.LINE - 15
        IF LINE.START < 1 THEN LINE.START = 1
        GOSUB DISPLAY.LINES
    END
*
    Y.POS = CURRENT.LINE - LINE.START + MARGIN.TOP
*
    GOSUB DISPLAY.HEADER
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.HEADER:NULL
*
    PRINT @(0,0) : CLEAR.REST.OF.LINE
    PRINT @(MARGIN.LEFT,0) :
    PRINT CLEAR.REST.OF.LINE :
    PRINT HEADER.COLOR :
    PRINT FILENAME : ' ' : RECORD.ID :
    PRINT ' C: ' : CURRENT.LINE :
    PRINT ' L: ' : LINE.NUMBERS<CURRENT.LINE> :
    PRINT ' X: ' : X.POS :
    PRINT ' Y: ' : Y.POS :
    PRINT ' LS: ' : LINE.START :
    PRINT ' LE: ' : LINE.END :
    PRINT ' CH: ' : X.POS - MARGIN.LEFT + 1 :
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.FOOTER:NULL
*
    PRINT BOTTOM : CLEAR.REST.OF.LINE :
    RETURN
*********************  S U B R O U T I N E  *********************
*
SETUP.DISPLAY:NULL
*
*TEMP     PRINT CLEAR.SCREEN :
    GOSUB DISPLAY.HEADER
    PRINT @(0,MARGIN.TOP) : WHITE :
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
CONVERT.RAW.LINES:NULL
*
    LINES = ''
    LINE.NUMBERS = ''
*
    CTR = 0
    RAW.LINE.CTR = 0
*
    NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
    IF NUMBER.OF.RAW.LINES = 0 THEN NUMBER.OF.RAW.LINES = 1
*
    LOOP
        CTR = CTR + 1
        RAW.LINE.CTR = RAW.LINE.CTR + 1
*
        RAW.LINE.LEN = LEN(RAW.LINES<RAW.LINE.CTR>)
*
        IF RAW.LINE.LEN < VIEW.WIDTH THEN
            LINES<CTR> = RAW.LINES<RAW.LINE.CTR>
            LINE.NUMBERS<CTR> = RAW.LINE.CTR
        END ELSE
            FOR J = 1 TO RAW.LINE.LEN STEP VIEW.WIDTH
                LINES<CTR> = RAW.LINES<RAW.LINE.CTR>[J,VIEW.WIDTH]
                LINE.NUMBERS<CTR> = RAW.LINE.CTR
                CTR = CTR + 1
            NEXT J
            CTR = CTR - 1
        END
    UNTIL RAW.LINE.CTR = NUMBER.OF.RAW.LINES DO REPEAT
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
COLORIZE.TOKEN:NULL
*
    LOCATE(TOKEN,STATEMENTS;ANY.POS) THEN
        TOKEN = STMT.COLOR : TOKEN : FOREGROUND.COLOR
        RETURN
    END
*
    LOCATE(TOKEN,FUNCTIONS;ANY.POS) THEN
        TOKEN = FUNCTION.COLOR : TOKEN : FOREGROUND.COLOR
        RETURN
    END
*
    LOCATE(TOKEN,OPERATORS;ANY.POS) THEN
        TOKEN = OPERATOR.COLOR : TOKEN : FOREGROUND.COLOR
        RETURN
    END
*
    LOCATE(TOKEN,SPECIALS;ANY.POS) THEN
        TOKEN = SPECIAL.COLOR : TOKEN : FOREGROUND.COLOR
        RETURN
    END
*
    IF TOKEN # '' AND NUM(TOKEN) THEN
        TOKEN = NUMBER.COLOR : TOKEN : FOREGROUND.COLOR
        RETURN
    END
*
    RETURN
*
*********************  s u b r o u t i n e  *********************
*
TOKENIZE.LINE:NULL
*
    IF FILETYPE = 'BASIC' THEN
        GOSUB TOKENIZE.LINE.BASIC
    END ELSE IF FILETYPE = 'PROC' THEN
        GOSUB TOKENIZE.LINE.PROC
    END ELSE IF FILETYPE = 'DATA' THEN
        GOSUB TOKENIZE.LINE.DATA
    END
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
TOKENIZE.LINE.BASIC:NULL
*
    TOKEN = ''
    TOKENS = ''
*
    CREATED.FIRST.TOKEN = FALSE
    HIT.SEMICOLON = FALSE
*
    FOR LETTER.CTR = 1 TO LEN(LINE)
        CHARACTER = LINE[LETTER.CTR,1]
*
        IF DQ.STACK.CTR # 0 OR CHARACTER = '"' THEN
            IF DQ.STACK.CTR = 0 THEN
                TOKENS<-1> = TOKEN
                DQ.STACK.CTR = 1
            END
*
            STRING = CHARACTER
            LETTER.CTR = LETTER.CTR + 1
*
            LOOP UNTIL DQ.STACK.CTR = 0 OR LETTER.CTR > LEN(LINE) DO
                CHARACTER = LINE[LETTER.CTR,1]
                LETTER.CTR = LETTER.CTR + 1
                IF CHARACTER = '"' THEN
                    DQ.STACK.CTR = DQ.STACK.CTR - 1
                END
                STRING = STRING : CHARACTER
            REPEAT
*
            CREATED.FIRST.TOKEN = TRUE
            TOKENS<-1> = STRING.COLOR : STRING : FOREGROUND.COLOR
            TOKEN = ''
            LETTER.CTR = LETTER.CTR - 1
*
        END ELSE IF SQ.STACK.CTR # 0 OR CHARACTER = "'" THEN
            IF SQ.STACK.CTR = 0 THEN
                TOKENS<-1> = TOKEN
            END
*
            STRING = CHARACTER
            LETTER.CTR = LETTER.CTR + 1
*
            IF SQ.STACK.CTR = 0 THEN
                SQ.STACK.CTR = 1
            END
*
            LOOP UNTIL SQ.STACK.CTR = 0 OR LETTER.CTR > LEN(LINE) DO
                CHARACTER = LINE[LETTER.CTR,1]
                LETTER.CTR = LETTER.CTR + 1
                IF CHARACTER = "'" THEN
                    SQ.STACK.CTR = SQ.STACK.CTR - 1
                END
                STRING = STRING : CHARACTER
            REPEAT
*
            CREATED.FIRST.TOKEN = TRUE
            TOKENS<-1> = STRING.COLOR : STRING : FOREGROUND.COLOR
            TOKEN = ''
            LETTER.CTR = LETTER.CTR - 1
*
        END ELSE IF CHARACTER = ';' THEN
            TOKENS<-1> = TOKEN
            HIT.SEMICOLON = TRUE
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = ';'
            TOKEN = ''
*
        END ELSE IF CHARACTER = '*' THEN
            IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
*
            IF CREATED.FIRST.TOKEN AND HIT.SEMICOLON = FALSE THEN
                TOKEN = '*'
                GOSUB COLORIZE.TOKEN
                TOKENS<-1> = TOKEN
                TOKEN = ''
*
            END ELSE
                TOKENS<-1> = COMMENT.COLOR : LINE[LETTER.CTR,999]
                TOKEN = ''
                LETTER.CTR = LEN(LINE)
            END
*
        END ELSE IF CHARACTER = ' ' THEN
            IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = ' '
            TOKEN = ''
*
        END ELSE IF ASCII(CHARACTER) = CHAR(253) THEN
            IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = STMT.COLOR : CHARACTER : FOREGROUND.COLOR
            TOKEN = ''
*
        END ELSE IF ASCII(CHARACTER) = CHAR(252) THEN
            IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = FUNCTION.COLOR : CHARACTER : FOREGROUND.COLOR
            TOKEN = ''
*
        END ELSE IF ASCII(CHARACTER) = CHAR(251) THEN
            IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = SPECIAL.COLOR : CHARACTER : FOREGROUND.COLOR
            TOKEN = ''
*
        END ELSE
            LOCATE(CHARACTER,BREAK.CHARACTERS;BREAK.POS) THEN
                IF TOKEN # '' THEN CREATED.FIRST.TOKEN = TRUE
                GOSUB COLORIZE.TOKEN
                TOKENS<-1> = TOKEN
                TOKEN = BREAK.CHARACTERS<BREAK.POS>
                GOSUB COLORIZE.TOKEN
                TOKENS<-1> = TOKEN
                TOKEN = ''
            END ELSE
                TOKEN = TOKEN : CHARACTER
            END
        END
    NEXT LETTER.CTR
*
    GOSUB COLORIZE.TOKEN
    TOKENS<-1> = TOKEN
*
    LINE = TOKENS
    CONVERT @AM TO '' IN LINE
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
TOKENIZE.LINE.PROC:NULL
*
    TOKEN = ''
    TOKENS = ''
    PROC.COMMANDS = 'PQ RI RO STON'
    CONVERT ' ' TO @AM IN PROC.COMMANDS
*
    FOR LETTER.CTR = 1 TO LEN(LINE)
        CHARACTER = LINE[LETTER.CTR,1]
*
        IF LETTER.CTR = 1 THEN
            TOKEN = CHARACTER
            TWO.CHARACTERS = LINE[1,2]
*
            LOCATE(LINE,PROC.COMMANDS;POS) THEN
                TOKENS<-1> = GREEN : LINE : FOREGROUND.COLOR
                LETTER.CTR = LEN(LINE)
                TOKEN = ''
                CONTINUE
            END
*
            IF TWO.CHARACTERS = 'IP' THEN
                TOKENS<-1> = GREEN : TWO.CHARACTERS : FOREGROUND.COLOR
                LETTER.CTR = LETTER.CTR + 1
                TOKEN = ''
*
            END ELSE IF TOKEN = 'H' THEN
                TOKENS<-1> = GREEN : TOKEN : FOREGROUND.COLOR
                TOKEN = ''
*
            END ELSE IF TOKEN = 'X' THEN
                TOKENS<-1> = GREEN : TOKEN : FOREGROUND.COLOR
                TOKEN = ''
*
            END ELSE IF TOKEN = 'U' THEN
                TOKENS<-1> = MAGENTA : LINE : FOREGROUND.COLOR
                LETTER.CTR = LEN(LINE)
                TOKEN = ''
*
            END ELSE IF TOKEN = 'A' THEN
                TOKENS<-1> = MAGENTA : LINE : FOREGROUND.COLOR
                LETTER.CTR = LEN(LINE)
                TOKEN = ''
*
            END ELSE IF TOKEN = 'O' THEN
                TOKENS<-1> = GREEN : LINE[1,1] : FOREGROUND.COLOR
                TOKENS<-1> = CYAN : LINE[2,999] : FOREGROUND.COLOR
                LETTER.CTR = LEN(LINE)
                TOKEN = ''
*
            END ELSE IF TOKEN = 'C' THEN
                TOKENS<-1> = COMMENT.COLOR : LINE : FOREGROUND.COLOR
                LETTER.CTR = LEN(LINE)
                TOKEN = ''
*
            END ELSE IF TOKEN = 'S' THEN
                TOKENS<-1> = GREEN : TOKEN : FOREGROUND.COLOR
                TOKEN = ''
*
            END ELSE IF TOKEN = 'P' THEN
                TOKENS<-1> = GREEN : TOKEN : FOREGROUND.COLOR
                TOKEN = ''
*
            END ELSE IF TOKEN = '(' THEN
                TOKENS<-1> = OPERATOR.COLOR : TOKEN : FOREGROUND.COLOR
                TOKEN = ''
            END
*
        END ELSE IF DQ.STACK.CTR # 0 OR CHARACTER = '"' THEN
            IF DQ.STACK.CTR = 0 THEN
                TOKENS<-1> = TOKEN
            END
            STRING = CHARACTER
            LETTER.CTR = LETTER.CTR + 1
*
            IF DQ.STACK.CTR = 0 THEN
                DQ.STACK.CTR = 1
            END
*
            LOOP UNTIL DQ.STACK.CTR = 0 OR LETTER.CTR > LEN(LINE) DO
                CHARACTER = LINE[LETTER.CTR,1]
                LETTER.CTR = LETTER.CTR + 1
                IF CHARACTER = '"' THEN
                    DQ.STACK.CTR = DQ.STACK.CTR - 1
                END
                STRING = STRING : CHARACTER
            REPEAT
*
            CREATED.FIRST.TOKEN = TRUE
            TOKENS<-1> = STRING.COLOR : STRING : FOREGROUND.COLOR
            TOKEN = ''
            LETTER.CTR = LETTER.CTR - 1
*
        END ELSE IF SQ.STACK.CTR # 0 OR CHARACTER = "'" THEN
            IF SQ.STACK.CTR = 0 THEN
                TOKENS<-1> = TOKEN
            END
*
            STRING = CHARACTER
            LETTER.CTR = LETTER.CTR + 1
*
            IF SQ.STACK.CTR = 0 THEN
                SQ.STACK.CTR = 1
            END
*
            LOOP UNTIL SQ.STACK.CTR = 0 OR LETTER.CTR > LEN(LINE) DO
                CHARACTER = LINE[LETTER.CTR,1]
                LETTER.CTR = LETTER.CTR + 1
                IF CHARACTER = "'" THEN
                    SQ.STACK.CTR = SQ.STACK.CTR - 1
                END
                STRING = STRING : CHARACTER
            REPEAT
*
            CREATED.FIRST.TOKEN = TRUE
            TOKENS<-1> = STRING.COLOR : STRING : FOREGROUND.COLOR
            TOKEN = ''
            LETTER.CTR = LETTER.CTR - 1
*
        END ELSE IF CHARACTER = ' ' THEN
            GOSUB COLORIZE.TOKEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = ' '
            TOKEN = ''
*
        END ELSE IF ASCII(CHARACTER) = CHAR(253) THEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = STMT.COLOR : CHARACTER : FOREGROUND.COLOR
            TOKEN = ''
*
        END ELSE IF ASCII(CHARACTER) = CHAR(252) THEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = FUNCTION.COLOR : CHARACTER : FOREGROUND.COLOR
            TOKEN = ''
*
        END ELSE IF ASCII(CHARACTER) = CHAR(251) THEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = SPECIAL.COLOR : CHARACTER : FOREGROUND.COLOR
            TOKEN = ''
*
        END ELSE
            LOCATE(CHARACTER,BREAK.CHARACTERS;BREAK.POS) THEN
                GOSUB COLORIZE.TOKEN
                TOKENS<-1> = TOKEN
                TOKEN = BREAK.CHARACTERS<BREAK.POS>
                GOSUB COLORIZE.TOKEN
                TOKENS<-1> = TOKEN
                TOKEN = ''
            END ELSE
                TOKEN = TOKEN : CHARACTER
            END
        END
    NEXT LETTER.CTR
*
    GOSUB COLORIZE.TOKEN
    TOKENS<-1> = TOKEN
*
    LINE = TOKENS
    CONVERT @AM TO '' IN LINE
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
TOKENIZE.LINE.DATA:NULL
*
    TOKEN = ''
    TOKENS = ''
*
    FOR LETTER.CTR = 1 TO LEN(LINE)
        CHARACTER = LINE[LETTER.CTR,1]
*
        IF ASCII(CHARACTER) = CHAR(253) THEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = STMT.COLOR : CHARACTER : FOREGROUND.COLOR
            TOKEN = ''
*
        END ELSE IF ASCII(CHARACTER) = CHAR(252) THEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = FUNCTION.COLOR : CHARACTER : FOREGROUND.COLOR
            TOKEN = ''
*
        END ELSE IF ASCII(CHARACTER) = CHAR(251) THEN
            TOKENS<-1> = TOKEN
            TOKENS<-1> = SPECIAL.COLOR : CHARACTER : FOREGROUND.COLOR
            TOKEN = ''
*
        END ELSE
            TOKEN = TOKEN : CHARACTER
        END
    NEXT LETTER.CTR
*
    TOKENS<-1> = TOKEN
*
    LINE = TOKENS
    CONVERT @AM TO '' IN LINE
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.LINES:NULL
*
    NUMBER.OF.LINES = DCOUNT(LINES,@AM)
    IF NUMBER.OF.LINES = 0 THEN NUMBER.OF.LINES = 1
*
    IF LINE.START < 1 THEN LINE.START = 1
*
    LINE.END = LINE.START + VIEW.HEIGHT - 1
    IF LINE.END > NUMBER.OF.LINES THEN LINE.END = NUMBER.OF.LINES
*
    IF (LINE.END - LINE.START) < VIEW.HEIGHT-1 THEN
        PRINT @(0,0) : CLEAR.SCREEN
    END
*
    GOSUB SETUP.DISPLAY
*
    DQ.STACK.CTR = 0
    SQ.STACK.CTR = 0
*
    PREV.LINE.NUMBER = 0
*
    PRINT @(0,MARGIN.TOP) :
    
    FOR I = LINE.START TO LINE.END
        LINE = LINES<I>
        LINE.NUMBER = LINE.NUMBERS<I>
        IF PREV.LINE.NUMBER # LINE.NUMBER THEN
            DQ.STACK.CTR = 0
            SQ.STACK.CTR = 0
        END
*
        GOSUB TOKENIZE.LINE
*
        IF VIEW.NUMBERS THEN
            PRINT LINE.NUMBER.COLOR : LINE.NUMBER PADDING.LEFT :
        END
        PRINT FOREGROUND.COLOR : LINE : CLEAR.REST.OF.LINE
*
        PREV.LINE.NUMBER = LINE.NUMBER
    NEXT I
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PRINT.CURRENT.LINE:NULL
*
    LINE = LINES<CURRENT.LINE>
    LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
    PREVIOUS.LINE = LINE.NUMBERS<CURRENT.LINE - 1>
    NEXT.LINE = LINE.NUMBERS<CURRENT.LINE + 1>
*
    IF PREVIOUS.LINE = LINE.NUMBER OR NEXT.LINE = LINE.NUMBER THEN
        GOSUB DISPLAY.LINES
        RETURN
    END
*
    DQ.STACK.CTR = 0
    SQ.STACK.CTR = 0
*
    GOSUB TOKENIZE.LINE
*
    PRINT @(0,Y.POS) : CLEAR.REST.OF.LINE :
    IF VIEW.NUMBERS THEN
        PRINT LINE.NUMBER.COLOR : LINE.NUMBER PADDING.LEFT :
    END
    PRINT FOREGROUND.COLOR : LINE
    PRINT @(X.POS,Y.POS) :
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.LINES.FROM.TO:NULL
*
    DQ.STACK.CTR = 0
    SQ.STACK.CTR = 0
*
    PREV.LINE.NUMBER = 0
*
    NUMBER.OF.LINES = DCOUNT(LINES,@AM)
    IF NUMBER.OF.LINES = 0 THEN NUMBER.OF.LINES = 1
*
    IF LINE.TO > NUMBER.OF.LINES THEN LINE.TO = NUMBER.OF.LINES
*
    LINES.FROM.CTR = 0
    FOR I = LINE.FROM TO LINE.TO
        LINE = LINES<I>
        LINE.NUMBER = LINE.NUMBERS<I>
        IF PREV.LINE.NUMBER # LINE.NUMBER THEN
            DQ.STACK.CTR = 0
            SQ.STACK.CTR = 0
        END
*
        PRINT @(0,Y.POS+LINES.FROM.CTR) : CLEAR.REST.OF.LINE :
        GOSUB TOKENIZE.LINE
        
        IF VIEW.NUMBERS THEN
            PRINT LINE.NUMBER.COLOR : LINE.NUMBER PADDING.LEFT :
        END
        PRINT FOREGROUND.COLOR : LINE :
        PREV.LINE.NUMBER = LINE.NUMBER
*
        LINES.FROM.CTR = LINES.FROM.CTR + 1
    NEXT I
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.ESCAPE.KEY:NULL
*
    ESCAPE.SEQUENCE = ''
    $IFDEF DATABASE.UV
        CHR = KEYIN()
    $ENDIF
    $IFDEF DATABASE.D3
        INPUT CHR,0
    $ENDIF
    ESCAPE.SEQUENCE = CHR
*
    IF CHR = 'O' THEN
        
        $IFDEF DATABASE.UV
            CHR = KEYIN()
        $ENDIF
        $IFDEF DATABASE.D3
            INPUT CHR,0
        $ENDIF
        ESCAPE.SEQUENCE = ESCAPE.SEQUENCE : CHR
    END ELSE IF CHR = '[' THEN
        LOOP
            $IFDEF DATABASE.UV
                CHR = KEYIN()
            $ENDIF
            $IFDEF DATABASE.D3
                INPUT CHR,0
            $ENDIF
            ESCAPE.SEQUENCE = ESCAPE.SEQUENCE : CHR
        UNTIL NOT(NUM(CHR)) DO REPEAT
    END ELSE
        INPUT.AVAILABLE = TRUE
        PROCESS.CHAR = CHR
    END
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.BASE.ESCAPE.KEY:NULL
*
    IF ESCAPE.SEQUENCE = PAGE.UP THEN
        GOSUB PRINT.CURRENT.LINE
*
        OLD.LINE.START = LINE.START
*
        LINE.START = LINE.START - PAGE.HEIGHT
        IF LINE.START < 1 THEN
            LINE.START = 1
        END
*
        IF OLD.LINE.START = LINE.START THEN
            PRINT @(X.POS, Y.POS) :
            RETURN
        END
*
        CURRENT.LINE = CURRENT.LINE - PAGE.HEIGHT
*
        IF CURRENT.LINE < 1 THEN
            CURRENT.LINE = 1
            Y.POS = MARGIN.TOP
        END ELSE
            Y.POS = CURRENT.LINE - LINE.START + MARGIN.TOP
        END
*
        GOSUB SET.X.POS
        GOSUB DISPLAY.HEADER
        GOSUB DISPLAY.LINES
        PRINT @(X.POS, Y.POS) :
*
    END ELSE IF ESCAPE.SEQUENCE = PAGE.DOWN THEN
        GOSUB PRINT.CURRENT.LINE
*
        NUMBER.OF.LINES = DCOUNT(LINES,@AM)
        IF LINE.START + PAGE.HEIGHT > NUMBER.OF.LINES THEN
            PRINT @(X.POS, Y.POS) :
            RETURN
        END
*
        LINE.START = LINE.START + PAGE.HEIGHT
*
        CURRENT.LINE = CURRENT.LINE + PAGE.HEIGHT
        IF CURRENT.LINE > NUMBER.OF.LINES THEN
            CURRENT.LINE = NUMBER.OF.LINES
            Y.POS = CURRENT.LINE - LINE.START + MARGIN.TOP
        END
*
        GOSUB SET.X.POS
        GOSUB DISPLAY.HEADER
        GOSUB DISPLAY.LINES
        PRINT @(X.POS, Y.POS) :
*
    END ELSE IF ESCAPE.SEQUENCE = UP.ARROW THEN
        GOSUB PRINT.CURRENT.LINE
        GOSUB SCROLL.UP
        PRINT @(X.POS, Y.POS) :
*
    END ELSE IF ESCAPE.SEQUENCE = DOWN.ARROW THEN
        GOSUB PRINT.CURRENT.LINE
        GOSUB SCROLL.DOWN
        PRINT @(X.POS, Y.POS) :
*
    END ELSE IF ESCAPE.SEQUENCE = LEFT.ARROW THEN
        GOSUB PRINT.CURRENT.LINE
        GOSUB SCROLL.LEFT
        PRINT @(X.POS, Y.POS) :
*
    END ELSE IF ESCAPE.SEQUENCE = RIGHT.ARROW THEN
        GOSUB PRINT.CURRENT.LINE
        GOSUB SCROLL.RIGHT
        PRINT @(X.POS, Y.POS) :
    END
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.EDITOR.COMMAND:NULL
*
    PRINT BOTTOM : CLEAR.REST.OF.LINE :
    PRINT EDITOR.COLOR : EDITOR.PROMPT : EDITOR.COMMAND :
*
    INPUT.PROMPT = EDITOR.PROMPT
    INPUT.STRING = ''
    INPUT.X.POS = 0
    INPUT.MARGIN.LEFT = EDITOR.MARGIN.LEFT
    INPUT.HISTORY = EDITOR.HISTORY
*
    IF EDITOR.COMMAND.AVAILABLE THEN
        EDITOR.COMMAND.AVAILABLE = FALSE
    END ELSE
        GOSUB PROCESS.INPUT
        EDITOR.COMMAND = INPUT.STRING
    END
*
    IF EDITOR.HISTORY<1,DCOUNT(EDITOR.HISTORY<1>,@VM)> # EDITOR.COMMAND THEN
        EDITOR.HISTORY<1,-1> = EDITOR.COMMAND
        IF EVA.HISTORY.OPENED THEN WRITEV EDITOR.HISTORY ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.EDITOR.ATTRIBUTE
    END
*
    IF EDITOR.COMMAND # '' AND NUM(EDITOR.COMMAND) THEN
        GOTO.LINE = EDITOR.COMMAND
        GOSUB GOTO.LINE.POSITION
        X.POS = MARGIN.LEFT
        PRINT @(X.POS,Y.POS) :
*
    END ELSE IF EDITOR.COMMAND = 'numbers' THEN
        VIEW.NUMBERS = NOT(VIEW.NUMBERS)
        NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
*
        IF VIEW.NUMBERS THEN
            IF NUMBER.OF.RAW.LINES < 10 THEN
                PADDING.LEFT = 'R#2 '
                MARGIN.LEFT = 2 + 1
            END ELSE
                PADDING.LEFT = 'R#' : LEN(NUMBER.OF.RAW.LINES) : ' '
                MARGIN.LEFT = LEN(NUMBER.OF.RAW.LINES) + 1
            END
        END ELSE
            MARGIN.LEFT = 0
        END
*
        GOSUB DISPLAY.LINES
        PRINT @(X.POS,Y.POS) :
*
    END ELSE IF EDITOR.COMMAND = 'archive' THEN
        IF ARCHIVE.OPENED THEN
            ARCHIVE.DATE = OCONV(DATE(),'D')
            CONVERT ' ' TO '' IN ARCHIVE.DATE
*
            ID.OK = FALSE
            SEQ = 0
            LOOP
                $IFDEF DATABASE.UV
                    ARCHIVE.ID = ARCHIVE.DATE : '*' : RECORD.ID
                $ENDIF
                $IFDEF DATABASE.D3
                    ARCHIVE.ID = FILENAME : '*' : ARCHIVE.DATE : '*' : RECORD.ID
                $ENDIF
                IF SEQ # 0 THEN ARCHIVE.ID = ARCHIVE.ID : '*' : SEQ
                READV ANYTHING FROM ARCHIVE.FILE, ARCHIVE.ID, 1 ELSE ID.OK = TRUE
            UNTIL ID.OK DO
                SEQ = SEQ + 1
            REPEAT
*
            WRITE RAW.LINES ON ARCHIVE.FILE, ARCHIVE.ID
*
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
            PRINT 'Archived in ' : ARCHIVE.FILENAME : ' as ' : ARCHIVE.ID :'.' :
*
        END ELSE
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
            PRINT 'Unable to archive.' :
        END
*
        PRINT @(X.POS,Y.POS) :
*
    END ELSE IF EDITOR.COMMAND[1,5] = 'count' THEN
        SUM = 0
        SUBSTRING = OCONV(EDITOR.COMMAND[7,9999],'MCU')
*
        NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
*
        FOR RAW.LINE.CTR = 1 TO NUMBER.OF.RAW.LINES
            SUM = SUM + COUNT(OCONV(RAW.LINES<RAW.LINE.CTR>,'MCU'),SUBSTRING)
        NEXT RAW.LINE.CTR
*
        PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
        PRINT 'Counted ' : SUM : ' occurances of ' : SUBSTRING :
        PRINT @(X.POS,Y.POS) :
*
    END ELSE IF EDITOR.COMMAND[1,5] = 'vlist' THEN
        EXECUTE 'VLIST ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
*
        GOSUB PUSH.EXPLODE
*
        INSIDE.VLIST = TRUE
*
        RAW.LINES = ''
        NUMBER.OF.VLIST = DCOUNT(RESULTS,@AM)
*
        FOR RESULT.CTR = 1 TO NUMBER.OF.VLIST
            IF RESULTS<RESULT.CTR> # '' THEN
                RAW.LINES<-1> = RESULTS<RESULT.CTR>
            END
        NEXT RESULT.CTR
*
        ORIGINAL.RAW.LINES = RAW.LINES
*
        HISTORY = ''
        HISTORY.X.Y = ''
        HISTORY.POS = 1
*
        CURRENT.LINE = 1
        LINE.START = 1
*
        GOSUB PUT.CURSOR.TOP.LEFT
        GOSUB CONVERT.RAW.LINES
        GOSUB DISPLAY.LINES
*
        PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
        PRINT 'VLIST ' : FILENAME : ' ' : RECORD.ID :
*
        GOSUB PUT.CURSOR.TOP.LEFT
*
    END ELSE IF EDITOR.COMMAND = 'r' THEN
        IF FILETYPE # 'BASIC' THEN RETURN
*
        GOSUB SAVE.FILE
        EXECUTE 'BASIC ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
*
        IF RESULTS<3> = '' THEN
            EXECUTE 'RUN ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
            PRINT CLEAR.SCREEN :
            PRINT @(0,0) :
            PRINT OCONV(TIME(),'MTS') : ': ' :
            PRINT 'SUCCESS -----------------'
            PRINT
*
            FOR J = 1 TO DCOUNT(RESULTS,@AM)
                PRINT RESULTS<J>
            NEXT J
*
            PRINT 'Program finished - Press Return : ' :
            INPUT ANYTHING :
*
            GOSUB DISPLAY.LINES
            PRINT @(X.POS,Y.POS) :
*
        END ELSE
            PRINT CLEAR.SCREEN :
            PRINT @(0,0) :
            PRINT OCONV(TIME(),'MTS') : ': ' :
            PRINT 'Error -----------------'
            PRINT
*
            FOR J = 1 TO DCOUNT(RESULTS,@AM)
                PRINT RESULTS<J>
            NEXT J
*
            PRINT 'Program finished - Press Return : ' :
            INPUT ANYTHING :
*
            GOSUB DISPLAY.LINES
            PRINT @(X.POS,Y.POS) :
        END
*
    END ELSE IF EDITOR.COMMAND = 'f' THEN
        GOSUB FORMAT.FILE
*
        PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
        PRINT 'Formatted file.' :
        PRINT @(X.POS,Y.POS) :
*
    END ELSE IF EDITOR.COMMAND[1,1] = 'a' THEN
        EDITOR.COMMAND = EDITOR.COMMAND[2,9999]
        REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
*
        NUMBER.OF.ARGUMENTS = DCOUNT(EDITOR.COMMAND,' ')
*
        APPEND.LINES = FIELD(EDITOR.COMMAND,' ',1)
        APPEND.STRING = FIELD(EDITOR.COMMAND,' ',2)
*
        IF APPEND.LINES = '' THEN APPEND.LINES = 1
*
        IF APPEND.STRING # '' THEN
            GOSUB PUSH.HISTORY
*
            LINES.LEFT = DCOUNT(RAW.LINES,@AM) - REAL.LINE.NUMBER
            IF APPEND.LINES > LINES.LEFT THEN
                APPEND.LINES = LINES.LEFT + 1
            END
*
            LINES.TO.APPEND.TO = REAL.LINE.NUMBER + APPEND.LINES - 1
*
            FOR APPEND.CTR = REAL.LINE.NUMBER TO LINES.TO.APPEND.TO
                RAW.LINES<APPEND.CTR> = RAW.LINES<APPEND.CTR> : APPEND.STRING
            NEXT I
*
            GOSUB CONVERT.RAW.LINES
            GOSUB DISPLAY.LINES
*
            PRINT @(X.POS,Y.POS) :
        END
*
    END ELSE IF EDITOR.COMMAND[1,1] = 'd' THEN
        GOSUB PUSH.HISTORY
*
        POSSIBLE.NUMBER = EDITOR.COMMAND[2,999]
        IF POSSIBLE.NUMBER = '' THEN
            POSSIBLE.NUMBER = 1
        END
*
        IF NOT(NUM(POSSIBLE.NUMBER)) THEN
            EDITOR.COMMAND = ''
            PRINT BOTTOM : CLEAR.REST.OF.LINE :
            PRINT @(X.POS,Y.POS) :
            RETURN
        END
*
        REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
        IF POSSIBLE.NUMBER > DCOUNT(RAW.LINES,@AM) - REAL.LINE.NUMBER + 1 THEN
            POSSIBLE.NUMBER = DCOUNT(RAW.LINES,@AM) - REAL.LINE.NUMBER + 1
            IF POSSIBLE.NUMBER = 0 THEN POSSIBLE.NUMBER = 1
        END
*
        FOR EDITOR.CTR = 1 TO POSSIBLE.NUMBER
            IF DCOUNT(RAW.LINES,@AM) = 0 THEN
                PRINT BOTTOM : CLEAR.REST.OF.LINE :
                PRINT @(X.POS,Y.POS) :
*
            END ELSE
                ORIGINAL.NUMBER.OF.LINES = DCOUNT(LINES,@AM)
*
                REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
                CURRENT.RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
                RAW.LINES = DELETE(RAW.LINES,REAL.LINE.NUMBER)
*
                IF LEN(CURRENT.RAW.LINE) < VIEW.WIDTH THEN
                    LINES = DELETE(LINES,CURRENT.LINE)
                    LINE.NUMBERS = DELETE(LINE.NUMBERS,CURRENT.LINE)
*
                    NUMBER.OF.LINES = DCOUNT(LINES,@AM)
                    FOR J = CURRENT.LINE TO NUMBER.OF.LINES
                        LINE.NUMBERS<J> = LINE.NUMBERS<J> - 1
                    NEXT J
                END ELSE
                    GOSUB CONVERT.RAW.LINES
                END
*
                IF DCOUNT(RAW.LINES,@AM) = 0 THEN
                    RAW.LINES<-1> = ''
                    LINES = ''
                    LINE.NUMBERS = 1
                END
*
                GOSUB DISPLAY.LINES
*
                IF CURRENT.LINE =  ORIGINAL.NUMBER.OF.LINES AND CURRENT.LINE # 1 THEN
                    Y.POS = Y.POS - 1
                    CURRENT.LINE = CURRENT.LINE - 1
                END
*
                PASTE.NEWLINE = TRUE
                YANKED.LINES = CURRENT.RAW.LINE
                IF EVA.HISTORY.OPENED THEN WRITEV YANKED.LINES ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.YANKED.ATTRIBUTE
*
                X.POS = MARGIN.LEFT
                PRINT @(X.POS,Y.POS) :
            END
        NEXT EDITOR.CTR
*
        EDITOR.COMMAND = ''
*
    END ELSE IF EDITOR.COMMAND[1,1] = '%' or EDITOR.COMMAND[1,1] = 's' THEN
        GOSUB PUSH.HISTORY
*
        REPLACE.PERCENT = FALSE
*
        IF EDITOR.COMMAND[1,1] = '%' AND EDITOR.COMMAND[2,1] = 's' THEN
            REPLACE.PERCENT = TRUE
            VALUE = EDITOR.COMMAND[3,999]
*
        END ELSE
            VALUE = EDITOR.COMMAND[2,999]
        END
*
        DELIMITER = VALUE[1,1]
        NEEDLE = FIELD(VALUE,DELIMITER,2)
        NEW.VALUE = FIELD(VALUE,DELIMITER,3)
        OCCURANCES = FIELD(VALUE,DELIMITER,4)
*
        IF REPLACE.PERCENT THEN
            OCCURANCES = 'G99999'
        END
*
        REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
        REPLACE.TO = REAL.LINE.NUMBER
*
        IF OCCURANCES # '' AND NUM(OCCURANCES) THEN
            NULL
*
        END ELSE IF OCONV(OCCURANCES[1,1],'MCU') = 'G' THEN
            NUMBER.OF.LINES = OCCURANCES[2,999]
            IF NUMBER.OF.LINES # '' AND NUM(NUMBER.OF.LINES) AND NUMBER.OF.LINES > 0 THEN
                NUMBER.OF.LINES = NUMBER.OF.LINES - 1
            END ELSE
                NUMBER.OF.LINES = DCOUNT(RAW.LINES,@AM)
            END
*
            REPLACE.TO = REAL.LINE.NUMBER + NUMBER.OF.LINES
*
            IF NOT(NUM(REPLACE.TO)) THEN
                REPLACE.TO = REAL.LINE.NUMBER
            END
*
            IF REPLACE.TO > DCOUNT(RAW.LINES,@AM) THEN
                REPLACE.TO = DCOUNT(RAW.LINES,@AM)
            END
*
            OCCURANCES = 0
*
        END ELSE
            OCCURANCES = 1
        END
*
        START.POS = REAL.LINE.NUMBER
        FOR REPLACE.LINE.CTR = START.POS TO REPLACE.TO
            REAL.LINE.NUMBER = REPLACE.LINE.CTR
*
            RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
            IF NEEDLE = '' THEN
                RAW.LINE = NEW.VALUE : RAW.LINE
            END ELSE
                RAW.LINE = CHANGE(RAW.LINE,NEEDLE,NEW.VALUE,OCCURANCES)
            END
*
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
            GOSUB UPDATE.LINE
        NEXT REPLACE.LINE.CTR
*
        GOSUB DISPLAY.LINES
        PRINT @(X.POS,Y.POS) :
*
    END ELSE IF EDITOR.COMMAND = 'ev' THEN
        GOSUB PUSH.EXPLODE
*
        $IFDEF DATABASE.UV
            RAISED.RECORD = RAISE(RAW.LINES<REAL.LINE.NUMBER>)
        $ENDIF
        $IFDEF DATABASE.D3
            RAISED.RECORD = RAW.LINES<REAL.LINE.NUMBER>
            CONVERT @VM:@SVM:@TM TO @AM:@VM:@SVM IN RAISED.RECORD
        $ENDIF
        RAW.LINES = RAISED.RECORD
*
        ORIGINAL.RAW.LINES = RAW.LINES
*
        HISTORY = ''
        HISTORY.X.Y = ''
        HISTORY.POS = 1
*
        CURRENT.LINE = 1
        LINE.START = 1
*
        GOSUB PUT.CURSOR.TOP.LEFT
        GOSUB CONVERT.RAW.LINES
        GOSUB DISPLAY.LINES
*
        PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
        PRINT 'Exploded line ' : CURRENT.LINE : '.' :
*
        GOSUB PUT.CURSOR.TOP.LEFT
*
    END ELSE IF EDITOR.COMMAND[1,1] = 'q' OR EDITOR.COMMAND = 'exk'  OR EDITOR.COMMAND = 'x' THEN
        IF NEST.LEVEL # 0 THEN
            IF ORIGINAL.RAW.LINES = RAW.LINES THEN
                SAVE.ROW = FALSE
                GOSUB POP.EXPLODE
*
            END ELSE
                PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
                PRINT 'There are unsaved changes. Are you sure you want to exit? (y/n) ' :
                INPUT ANSWER :
*
                IF OCONV(ANSWER,'MCL') = 'y' THEN
                    SAVE.ROW = FALSE
                    GOSUB POP.EXPLODE
                END
*
                PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
                PRINT @(X.POS,Y.POS) :
            END
*
        END ELSE
            IF ORIGINAL.RAW.LINES = RAW.LINES OR EDITOR.COMMAND[2,1] = '!' THEN
                IF EDITOR.COMMAND = 'exk' OR EDITOR.COMMAND = 'x' THEN QUIT.ALL.FLAG = TRUE
                QUIT.FLAG = TRUE
*
            END ELSE
                PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
                PRINT 'There are unsaved changes. Are you sure you want to exit? (y/n) ' :
                INPUT ANSWER :
*
                IF OCONV(ANSWER,'MCL') = 'y' THEN
                    IF EDITOR.COMMAND = 'exk' OR EDITOR.COMMAND = 'x' THEN QUIT.ALL.FLAG = TRUE
                    QUIT.FLAG = TRUE
                END
*
                PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
                PRINT @(X.POS,Y.POS) :
            END
        END
*
    END ELSE IF EDITOR.COMMAND[1,1] = 'w' THEN
        GOSUB SAVE.FILE
        GOSUB COMPILE.FILE
*
        IF NEST.LEVEL = 0 AND EDITOR.COMMAND[2,1] = 'q' THEN
            QUIT.FLAG = TRUE
        END
*
    END ELSE IF EDITOR.COMMAND = 'fd' THEN
        PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
        PRINT 'You are trying to delete the entire record. Are you sure? (y/n) ' :
*
        INPUT ANS :
        IF ANS = 'Y' THEN
            DELETE FILE,RECORD.ID
            QUIT.FLAG = TRUE
        END
*
        PRINT BOTTOM : CLEAR.REST.OF.LINE :
        PRINT @(X.POS,Y.POS) :
*
    END ELSE IF EDITOR.COMMAND[1,4] = 'load' THEN
        NUMBER.OF.ARGUMENTS = DCOUNT(EDITOR.COMMAND,' ')
*
        IF NUMBER.OF.ARGUMENTS = 2 THEN
            DICT = ''
            LOAD.FILENAME = FILENAME
            LOAD.ITEM.ID = FIELD(EDITOR.COMMAND,' ',2)
*
        END ELSE IF NUMBER.OF.ARGUMENTS = 3 THEN
            DICT = ''
            LOAD.FILENAME = FIELD(EDITOR.COMMAND,' ',2)
            LOAD.ITEM.ID = FIELD(EDITOR.COMMAND,' ',3)
*
        END ELSE IF NUMBER.OF.ARGUMENTS = 4 THEN
            DICT = 'DICT'
            LOAD.FILENAME = FIELD(EDITOR.COMMAND,' ',3)
            LOAD.ITEM.ID = FIELD(EDITOR.COMMAND,' ',4)
        END
*
        OPEN DICT,LOAD.FILENAME TO LOAD.FILE THEN
            READ LOAD.ITEM FROM LOAD.FILE,LOAD.ITEM.ID THEN
                GOSUB PUSH.HISTORY
*
                PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
                PRINT 'Starting line/field number: ' :
                INPUT LOAD.START :
*
                PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
                PRINT 'Ending line/field number: ' :
                INPUT LOAD.END :
*
                LOAD.LENGTH = DCOUNT(LOAD.ITEM,@AM)
                IF LOAD.END > LOAD.LENGTH THEN
                    LOAD.END = LOAD.LENGTH
                END
                IF LOAD.END < LOAD.START THEN
                    LOAD.END = LOAD.START
                END
*
                IF DCOUNT(RAW.LINES,@AM) = 0 THEN
                    INSERT.AT.LINE = 1
                END ELSE
                    REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
                    INSERT.AT.LINE = REAL.LINE.NUMBER + 1
                END
*
                LINE.COUNTER = 0
                FOR I = LOAD.START TO LOAD.END
                    RAW.LINES = INSERT(RAW.LINES,INSERT.AT.LINE;LOAD.ITEM<I>)
                    INSERT.AT.LINE = INSERT.AT.LINE + 1
                    LINE.COUNTER = LINE.COUNTER + 1
                NEXT I
*
                GOSUB CONVERT.RAW.LINES
                GOSUB DISPLAY.LINES
*
                PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
                PRINT LINE.COUNTER : ' lines/fields loaded.' :
*
            END ELSE
                PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
                PRINT 'Unable to open record: ' : LOAD.ITEM.ID :
            END
        END ELSE
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT 'Unable to open file: ' : LOAD.FILENAME :
        END
*
        PRINT @(X.POS,Y.POS) :
*
    END ELSE
        PRINT BOTTOM : CLEAR.REST.OF.LINE :
        PRINT @(X.POS,Y.POS) :
    END
*
    EDITOR.COMMAND = ''
*
    RETURN
*
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.SEARCH.INPUT:NULL
*
    PRINT BOTTOM : EDITOR.COLOR : CLEAR.REST.OF.LINE :
    PRINT SEARCH.PROMPT :
*
    INPUT.PROMPT = SEARCH.PROMPT
    INPUT.STRING = ''
    INPUT.X.POS = 0
    INPUT.MARGIN.LEFT = SEARCH.MARGIN.LEFT
    INPUT.HISTORY = SEARCH.HISTORY
*
    GOSUB PROCESS.INPUT
*
    SEARCH.STRING = INPUT.STRING
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.SEARCH:NULL
*
    IF SEARCH.STRING = '' THEN
        SEARCH.STRING = ORIGINAL.SEARCH.STRING
        IF SEARCH.STRING = '' THEN
            PRINT BOTTOM : CLEAR.REST.OF.LINE :
            PRINT @(X.POS,Y.POS) :
            RETURN
        END
    END
*
    IF SEARCH.HISTORY<1,DCOUNT(SEARCH.HISTORY<1>,@VM)> # SEARCH.STRING THEN
        SEARCH.HISTORY<1,-1> = SEARCH.STRING
        IF EVA.HISTORY.OPENED THEN WRITEV SEARCH.HISTORY ON EVA.HISTORY.FILE,EVA.HISTORY.NAME,EVA.SEARCH.ATTRIBUTE
    END
*
    ORIGINAL.SEARCH.STRING = SEARCH.STRING
    SEARCH.FOUND = FALSE
    SEARCH.RESULTS = ''
*
    SEARCH.CTR = 0
*
    STARTING.SEARCH.POS = 1
    STARTING.SEARCH.LINE = LINE.NUMBERS<CURRENT.LINE>
    STARTING.SEARCH.FOUND = FALSE
*
    NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
*
    FOR REAL.LINE.NUMBER = 1 TO NUMBER.OF.RAW.LINES
        RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
        SEARCH.OCCURANCE = 0
*
        LOOP
            SEARCH.OCCURANCE = SEARCH.OCCURANCE + 1
            FOUND.POS = INDEX(OCONV(RAW.LINE,'MCU'),OCONV(SEARCH.STRING,'MCU'),SEARCH.OCCURANCE)
*
        UNTIL FOUND.POS = 0 DO
            SEARCH.CTR = SEARCH.CTR + 1
            SEARCH.RESULTS<SEARCH.CTR,1> = REAL.LINE.NUMBER
            SEARCH.RESULTS<SEARCH.CTR,2> = FOUND.POS
            IF NOT(STARTING.SEARCH.FOUND) AND REAL.LINE.NUMBER > STARTING.SEARCH.LINE THEN
                STARTING.SEARCH.POS = SEARCH.CTR
                STARTING.SEARCH.FOUND = TRUE
            END
        REPEAT
    NEXT SEARCH.CTR
*
    IF SEARCH.RESULTS = '' THEN
        SEARCH.POSITION = 0
        ERROR.MESSAGE = 'No results for: "' : SEARCH.STRING : '"'
        PRINT BOTTOM : CLEAR.REST.OF.LINE :
        PRINT ERROR.MESSAGE :
        PRINT @(X.POS,Y.POS) :
    END
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
GOTO.SEARCH.RESULT:NULL
*
    GOTO.LINE = SEARCH.RESULTS<SEARCH.POSITION,1>
    FOUND.POS = SEARCH.RESULTS<SEARCH.POSITION,2>
*
    GOSUB GOTO.LINE.POSITION
*
    IF FOUND.POS <= VIEW.WIDTH THEN
        X.POS = FOUND.POS + MARGIN.LEFT - 1
*
    END ELSE
        NUMBER.OF.LINES = INT(FOUND.POS / VIEW.WIDTH)
*
        X.POS = FOUND.POS - ((NUMBER.OF.LINES) * VIEW.WIDTH) + MARGIN.LEFT - 1
        Y.POS = Y.POS + NUMBER.OF.LINES
        CURRENT.LINE = CURRENT.LINE + NUMBER.OF.LINES
    END
*
    PRINT @(X.POS,Y.POS) :
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.INPUT:NULL
*
    INPUT.SEARCH.TRIGGERED = FALSE
    INPUT.SEARCH.TERM = ''
*
    INPUT.HISTORY.POS = DCOUNT(INPUT.HISTORY,@VM) + 1
*
    LOOP WHILE TRUE DO
        $IFDEF DATABASE.UV
            CHR = KEYIN()
        $ENDIF
        $IFDEF DATABASE.D3
            INPUT CHR,0
        $ENDIF
*
        ASCII.CODE = SEQ(CHR)
*
        IF ASCII.CODE = SEQ(KEY.ESCAPE) THEN
            GOSUB PROCESS.ESCAPE.KEY
            IF ESCAPE.SEQUENCE = LEFT.ARROW THEN
                IF INPUT.X.POS > 0 THEN
                    INPUT.X.POS = INPUT.X.POS - 1
                END
            END ELSE IF ESCAPE.SEQUENCE = RIGHT.ARROW THEN
                IF INPUT.X.POS < LEN(INPUT.STRING) THEN
                    INPUT.X.POS = INPUT.X.POS + 1
                END
            END ELSE IF ESCAPE.SEQUENCE = UP.ARROW THEN
                IF NOT(INPUT.SEARCH.TRIGGERED) THEN
                    IF INPUT.HISTORY.POS > 1 THEN
                        INPUT.HISTORY.POS = INPUT.HISTORY.POS - 1
                        INPUT.STRING = INPUT.HISTORY<1,INPUT.HISTORY.POS>
                        INPUT.X.POS = LEN(INPUT.STRING)
                    END
                END ELSE
                    OLD.INPUT.HISTORY.POS = INPUT.HISTORY.POS
                    INPUT.HISTORY.POS = INPUT.HISTORY.POS - 1
                    IF INPUT.HISTORY.POS = 0 THEN INPUT.HISTORY.POS = 1
*
                    LOOP
                        PREV.INPUT = INPUT.HISTORY<1, INPUT.HISTORY.POS>
                        INPUT.HISTORY.RESULT = INDEX(OCONV(PREV.INPUT,'MCU'),OCONV(INPUT.SEARCH.TERM,'MCU'),1)
                    UNTIL (INPUT.HISTORY.POS <= 1 OR INPUT.HISTORY.RESULT # 0) DO
                        INPUT.HISTORY.POS = INPUT.HISTORY.POS - 1
                    REPEAT
*
                    IF INPUT.HISTORY.RESULT = 0 THEN
                        PREV.INPUT = INPUT.HISTORY<1, OLD.INPUT.HISTORY.POS>
                        INPUT.HISTORY.POS = OLD.INPUT.HISTORY.POS
                    END
*
                    INPUT.STRING = PREV.INPUT
                    INPUT.X.POS = LEN(INPUT.STRING)
                END
*
            END ELSE IF ESCAPE.SEQUENCE = DOWN.ARROW THEN
                IF NOT(INPUT.SEARCH.TRIGGERED) THEN
                    IF INPUT.HISTORY.POS < DCOUNT(INPUT.HISTORY,@VM) THEN
                        INPUT.HISTORY.POS = INPUT.HISTORY.POS + 1
                        INPUT.STRING = INPUT.HISTORY<1,INPUT.HISTORY.POS>
                        INPUT.X.POS = LEN(INPUT.STRING)
                    END
*
                END ELSE
                    OLD.INPUT.HISTORY.POS = INPUT.HISTORY.POS
                    INPUT.HISTORY.LEN = DCOUNT(INPUT.HISTORY<1>,@VM)
                    INPUT.HISTORY.POS = INPUT.HISTORY.POS + 1
*
                    LOOP
                        NEXT.INPUT = INPUT.HISTORY<1, INPUT.HISTORY.POS>
                        INPUT.HISTORY.RESULT = INDEX(OCONV(NEXT.INPUT,'MCU'),OCONV(INPUT.SEARCH.TERM,'MCU'),1)
                    UNTIL (INPUT.HISTORY.POS > INPUT.HISTORY.LEN OR INPUT.HISTORY.RESULT # 0) DO
                        INPUT.HISTORY.POS = INPUT.HISTORY.POS + 1
                    REPEAT
*
                    IF INPUT.HISTORY.RESULT = 0 THEN
                        NEXT.INPUT = INPUT.HISTORY<1, OLD.INPUT.HISTORY.POS>
                        INPUT.HISTORY.POS = OLD.INPUT.HISTORY.POS
                    END
*
                    INPUT.STRING = NEXT.INPUT
                    INPUT.X.POS = LEN(INPUT.STRING)
                END
            END
*
        END ELSE IF ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) THEN
            EXIT
*
        END ELSE IF ASCII.CODE = SEQ(KEY.BACKSPACE) THEN
            IF INPUT.X.POS <= 0 THEN
                EXIT
*
            END ELSE
                INPUT.STRING = INPUT.STRING[1,INPUT.X.POS-1] : INPUT.STRING[INPUT.X.POS+1,9999]
                INPUT.X.POS = INPUT.X.POS - 1
            END
*
        END ELSE
            INPUT.SEARCH.TRIGGERED = TRUE
            INPUT.STRING = INPUT.STRING[1,INPUT.X.POS] : CHR : INPUT.STRING[INPUT.X.POS+1,9999]
            INPUT.X.POS = INPUT.X.POS + 1
            INPUT.SEARCH.TERM = INPUT.STRING
        END
*
        PRINT BOTTOM : EDITOR.COLOR : INPUT.PROMPT : INPUT.STRING : CLEAR.REST.OF.LINE :
        PRINT @(INPUT.X.POS + INPUT.MARGIN.LEFT) :
    REPEAT
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
GET.INSERT.CHAR.POS:NULL
*
    REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
    LOCATE(REAL.LINE.NUMBER,LINE.NUMBERS;LINE.START.POS) ELSE LINE.START.POS = CURRENT.LINE
*
    PREV.CTR = CURRENT.LINE - LINE.START.POS
    INSERT.CHAR.POSITION = (PREV.CTR * VIEW.WIDTH) + X.POS - MARGIN.LEFT
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
* UPDATE LINE GIVEN A REAL.LINE.NUMBER
*
* 1. GET ALL LINES THAT BELONG TO REAL.LINE.NUMBER
* 2. DELETE THEM
* 3. CHUNK THE RAW.LINE
* 4. INSERT THEM BACK INTO LINES
*
UPDATE.LINE:NULL
*
    LOCATE(REAL.LINE.NUMBER,LINE.NUMBERS;LINE.START.POS) ELSE LINE.START.POS = CURRENT.LINE
*
    DONE = FALSE
    LINE.POS = LINE.START.POS
*
    LOOP UNTIL DONE DO
        IF LINE.NUMBERS<LINE.POS> = REAL.LINE.NUMBER THEN
            LINES = DELETE(LINES,LINE.POS)
            LINE.NUMBERS = DELETE(LINE.NUMBERS,LINE.POS)
        END ELSE
            DONE = TRUE
        END
    REPEAT
*
    RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
    RAW.LINE.LEN = LEN(RAW.LINE)
    IF RAW.LINE.LEN = 0 THEN RAW.LINE.LEN = 1
*
    INSERT.LINE.POS = LINE.START.POS
    FOR J = 1 TO RAW.LINE.LEN STEP VIEW.WIDTH
        LINES = INSERT(LINES,INSERT.LINE.POS;RAW.LINE[J,VIEW.WIDTH])
        LINE.NUMBERS = INSERT(LINE.NUMBERS,INSERT.LINE.POS;REAL.LINE.NUMBER)
        INSERT.LINE.POS = INSERT.LINE.POS + 1
    NEXT J
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.INSERT.LINE:NULL
*
    GOSUB PUSH.HISTORY
*
    REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
    CURRENT.RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
    IF INSERT.LINE = '' THEN
        RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
        NUMBER.OF.SPACES = INDEX(RAW.LINE,TRIMF(RAW.LINE),1) - 1
        INSERT.LINE = SPACE(NUMBER.OF.SPACES)
        X.POS = NUMBER.OF.SPACES + MARGIN.LEFT
    END ELSE
        X.POS = MARGIN.LEFT
    END
*
    RAW.LINES = INSERT(RAW.LINES,REAL.LINE.NUMBER+1;INSERT.LINE)
    NEXT.LINE.NUMBER = REAL.LINE.NUMBER + 1
*
    IF LEN(CURRENT.RAW.LINE) < VIEW.WIDTH THEN
        LINES = INSERT(LINES,CURRENT.LINE+1;INSERT.LINE)
        LINE.NUMBERS = INSERT(LINE.NUMBERS,CURRENT.LINE+1;REAL.LINE.NUMBER)
*
        NUMBER.OF.LINES = DCOUNT(LINES,@AM)
*
* REAL.LINE.NUMBER INSERTED WILL GET BUMPED UP BY THE FOR LOOP
* FOR LOOP STARTS AT THE INSERTED POSITION TO THE END
*
        FOR J = CURRENT.LINE+1 TO NUMBER.OF.LINES
            LINE.NUMBERS<J> = LINE.NUMBERS<J> + 1
        NEXT J
    END ELSE
        GOSUB CONVERT.RAW.LINES
    END
*
    LOCATE(NEXT.LINE.NUMBER,LINE.NUMBERS;CURRENT.LINE) ELSE CURRENT.LINE = 1
*
    NUMBER.OF.LINES = INT(LEN(RAW.LINES<REAL.LINE.NUMBER>) / VIEW.WIDTH)
    Y.POS = Y.POS + NUMBER.OF.LINES + 1
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.DELETE.LINE:NULL
*
    GOSUB PUSH.HISTORY
*
    PRINT @(X.POS,Y.POS) :
*
    EDITOR.COMMAND = 'd'
*
    LOOP
        $IFDEF DATABASE.UV
            CHR = KEYIN()
        $ENDIF
        $IFDEF DATABASE.D3
            INPUT CHR,0
        $ENDIF
        ASCII.CODE = SEQ(CHR)
    UNTIL ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) OR NOT(NUM(CHR)) DO
        EDITOR.COMMAND = EDITOR.COMMAND : CHR
    REPEAT
*
    IF ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) OR EDITOR.COMMAND = 'd' THEN
        EDITOR.COMMAND.AVAILABLE = TRUE
        GOSUB PROCESS.EDITOR.COMMAND
    END
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.INSERT:NULL
*
    PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
    PRINT @(X.POS,Y.POS) :
*
    LOOP WHILE TRUE DO
        $IFDEF DATABASE.UV
            CHR = KEYIN()
        $ENDIF
        $IFDEF DATABASE.D3
            INPUT CHR,0
        $ENDIF
        ASCII.CODE = SEQ(CHR)
*
        IF CHR = '`' THEN
            IF CC.LIST.OPEN THEN
                CC.LIST.OPEN = FALSE
                GOSUB DISPLAY.LINES
            END
*
            INPUT.AVAILABLE = FALSE
            PROCESS.CHAR = ''
            PRINT BOTTOM : CLEAR.REST.OF.LINE :
            PRINT @(X.POS,Y.POS) :
            EXIT
*
        END ELSE IF ASCII.CODE = SEQ(KEY.CTRL.S) THEN
            GOSUB SAVE.FILE
*
        END ELSE IF ASCII.CODE = SEQ(KEY.ESCAPE) THEN
            GOSUB PROCESS.ESCAPE.KEY
*
            IF ESCAPE.SEQUENCE = UP.ARROW THEN
                GOSUB SCROLL.UP
                PRINT @(X.POS,Y.POS) :
                CONTINUE
*
            END ELSE IF ESCAPE.SEQUENCE = DOWN.ARROW THEN
                GOSUB SCROLL.DOWN
                PRINT @(X.POS,Y.POS) :
                CONTINUE
*
            END ELSE IF ESCAPE.SEQUENCE = LEFT.ARROW THEN
                GOSUB PRINT.CURRENT.LINE
                GOSUB SCROLL.LEFT
                PRINT @(X.POS,Y.POS) :
*
            END ELSE IF ESCAPE.SEQUENCE = RIGHT.ARROW THEN
                GOSUB PRINT.CURRENT.LINE
                GOSUB SCROLL.RIGHT
                PRINT @(X.POS,Y.POS) :
*
            END ELSE
                IF CC.LIST.OPEN THEN
                    CC.LIST.OPEN = FALSE
                    GOSUB DISPLAY.LINES
                END
*
                PRINT BOTTOM : CLEAR.REST.OF.LINE :
                PRINT @(X.POS,Y.POS) :
                EXIT
            END
*
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            PRINT @(X.POS,Y.POS) :
            CONTINUE
*
        END ELSE IF ASCII.CODE = SEQ(KEY.TAB) THEN
            GOSUB PUSH.HISTORY
*
            REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
            GOSUB GET.INSERT.CHAR.POS
*
            RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
            RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION] : SPACE(TAB.SIZE) : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
            GOSUB UPDATE.LINE
*
            GOSUB PRINT.CURRENT.LINE
*
            X.POS = X.POS + TAB.SIZE
            IF X.POS > SCREEN.WIDTH - MARGIN.RIGHT THEN
                X.POS = MARGIN.LEFT + 1
                Y.POS = Y.POS + 1
                CURRENT.LINE = CURRENT.LINE + 1
            END
*
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            PRINT @(X.POS,Y.POS) :
            
*
        END ELSE IF ASCII.CODE = SEQ(KEY.BACKSPACE) THEN
            GOSUB PUSH.HISTORY
*
            IF X.POS > MARGIN.LEFT THEN
                REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
                GOSUB GET.INSERT.CHAR.POS
*
                RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
                DELETE.CHAR = RAW.LINE[INSERT.CHAR.POSITION,1]
*
                IF CC.LIST.OPEN THEN
                    CC.LIST.OPEN = FALSE
                    GOSUB DISPLAY.LINES
                END
*
                DELETE.TAB = FALSE
*
                IF DELETE.CHAR = ' ' AND INSERT.CHAR.POSITION >= TAB.SIZE THEN
                    TAB.TEST = RAW.LINE[INSERT.CHAR.POSITION-TAB.SIZE,TAB.SIZE]
                    TAB.TEST = TRIMF(TRIMB(TAB.TEST))
                    IF TAB.TEST = '' THEN DELETE.TAB = TRUE
                END
*
                RAW.LINE.LEN = LEN(RAW.LINE)
*
                IF DELETE.TAB THEN
                    RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION-TAB.SIZE] : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
                    X.POS = X.POS - TAB.SIZE
                END ELSE
                    RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION-1] : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
                    X.POS = X.POS - 1
                END
*
                RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
                GOSUB UPDATE.LINE
*
                IF RAW.LINE.LEN < VIEW.WIDTH THEN
                    GOSUB PRINT.CURRENT.LINE
                END ELSE
                    GOSUB DISPLAY.LINES
                END
*
            END ELSE IF Y.POS > 1 THEN
                PREV.LINE = CURRENT.LINE - 1
                REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
                PREV.LINE.NUMBER = LINE.NUMBERS<PREV.LINE>
*
                IF REAL.LINE.NUMBER = PREV.LINE.NUMBER THEN
                    GOSUB GET.INSERT.CHAR.POS
*
                    RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
                    RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION-1] : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
                    RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
                    GOSUB UPDATE.LINE
                    GOSUB DISPLAY.LINES
*
                    X.POS = SCREEN.WIDTH - MARGIN.RIGHT - 1
                    Y.POS = Y.POS - 1
                    CURRENT.LINE = CURRENT.LINE - 1
*
                END ELSE
                    RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
                    PREV.LINE = RAW.LINES<PREV.LINE.NUMBER>
*
                    NUMBER.OF.LINES = INT(LEN(PREV.LINE) / VIEW.WIDTH)
*
                    X.POS = (LEN(PREV.LINE) - (NUMBER.OF.LINES * VIEW.WIDTH)) + MARGIN.LEFT
                    Y.POS = Y.POS - 1
                    CURRENT.LINE = CURRENT.LINE - 1
*
                    RAW.LINES = DELETE(RAW.LINES,REAL.LINE.NUMBER)
                    RAW.LINES<PREV.LINE.NUMBER> = PREV.LINE : RAW.LINE
                END
*
                GOSUB CONVERT.RAW.LINES
                GOSUB DISPLAY.LINES
            END
*
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            PRINT @(X.POS,Y.POS) :
*
        END ELSE IF ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN) THEN
            GOSUB PUSH.HISTORY
*
            REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
            GOSUB GET.INSERT.CHAR.POS
*
            RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
*
            IF CC.LIST.OPEN THEN
                CC.WORD = CC.LIST<CC.POS,1>
                CC.DESCRIPTION = CC.LIST<CC.POS,2>
                CC.STRUCTURE = CC.LIST<CC.POS,3>
*
                IF CC.STRUCTURE # '' THEN
                    L = RAW.LINE[1,INSERT.CHAR.POSITION-CC.TRIGGER.LEN] : CC.STRUCTURE<1,1,1> : RAW.LINE[INSERT.CHAR.POSITION+1,999]
                    RAW.LINES<REAL.LINE.NUMBER> = L
                    FOR CC.LINE.CTR = 2 TO DCOUNT(CC.STRUCTURE,@SVM)
                        CC.LINE = CC.STRUCTURE<1,1,CC.LINE.CTR>
                        RAW.LINES = INSERT(RAW.LINES,REAL.LINE.NUMBER+CC.LINE.CTR-1;CC.LINE)
                    NEXT CC.LINE.CTR
                END ELSE
                    L = RAW.LINE[1,INSERT.CHAR.POSITION-CC.TRIGGER.LEN] : CC.WORD : RAW.LINE[INSERT.CHAR.POSITION+1,999]
                    RAW.LINES<REAL.LINE.NUMBER> = L
                END
*
                CC.LIST.OPEN = FALSE
*
                GOSUB CONVERT.RAW.LINES
                GOSUB DISPLAY.LINES
*
                X.POS = X.POS + LEN(CC.WORD) - CC.TRIGGER.LEN
*
                PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
                PRINT @(X.POS,Y.POS) :
*
                CONTINUE
            END
*
            ORIGINAL.LINE = RAW.LINE[1,INSERT.CHAR.POSITION]
            NEXT.LINE = RAW.LINE[INSERT.CHAR.POSITION+1,9999]
*
            RAW.LINES<REAL.LINE.NUMBER> = ORIGINAL.LINE
            RAW.LINES = INSERT(RAW.LINES,REAL.LINE.NUMBER+1;NEXT.LINE)
*
            NEXT.LINE.NUMBER = REAL.LINE.NUMBER + 1
*
            GOSUB CC.TOKENIZE.LINE
*
            GOSUB CONVERT.RAW.LINES
            GOSUB DISPLAY.LINES
*
            CURRENT.LINE = CURRENT.LINE + 1
*
            X.POS = MARGIN.LEFT
            Y.POS = Y.POS + 1
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            PRINT @(X.POS,Y.POS) :
*
        END ELSE
            GOSUB PUSH.HISTORY
*
            REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
            GOSUB GET.INSERT.CHAR.POS
*
            RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
            RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION] : CHR : RAW.LINE[INSERT.CHAR.POSITION+1,9999]
            RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
            LOCATE(CHR,CC.BREAK.CHARACTERS;BREAK.POS) THEN
                IF CC.LIST.OPEN THEN
                    CC.LIST.OPEN = FALSE
                    GOSUB DISPLAY.LINES
                END
            END
*
            IF CHR = ' ' THEN
                GOSUB CC.TOKENIZE.LINE
            END ELSE
                LOCATE(CHR,CC.BREAK.CHARACTERS;ANYPOS) THEN
                    GOSUB CC.TOKENIZE.LINE
                END
            END
*
            GOSUB UPDATE.LINE
*
            X.POS = X.POS + 1
            IF X.POS > SCREEN.WIDTH - MARGIN.RIGHT THEN
                X.POS = MARGIN.LEFT + 1
                Y.POS = Y.POS + 1
                CURRENT.LINE = CURRENT.LINE + 1
            END
*
            LINE = LINES<CURRENT.LINE>
            CURRENT.WORD = ''
            CURSOR.POSITION = X.POS - MARGIN.LEFT
*
            IF CURSOR.POSITION > 1 THEN
                FOR CC.WORD.START = CURSOR.POSITION TO 1 STEP -1
                    CHARACTER = LINE[CC.WORD.START,1]
                    LOCATE(CHARACTER,CC.BREAK.CHARACTERS;BREAK.POS) THEN
                        EXIT
                    END
                    CURRENT.WORD = CHARACTER : CURRENT.WORD
                NEXT CC.WORD.START
            END
*
            IF CURRENT.WORD = '' OR LEN(CURRENT.WORD) < 2 THEN
                CC.LIST.OPEN = FALSE
                CC.LIST = ''
*
            END ELSE
                CC.LIST = ''
                FOR LIST.CTR = 1 TO DCOUNT(SNIPPETS,@AM)
                    IF INDEX(OCONV(SNIPPETS<LIST.CTR,1>,'MCU'),OCONV(CURRENT.WORD,'MCU'),1) = 1 THEN
                        CC.LIST<-1> = SNIPPETS<LIST.CTR>
                    END
                NEXT LIST.CTR
            END
*
            IF DCOUNT(CC.LIST,@AM) > 0 THEN
                CC.LIST.OPEN = TRUE
                CC.POS = 1
                CC.TRIGGER.LEN = LEN(CURRENT.WORD)
*
                LINE.FROM = CURRENT.LINE
                LINE.TO = CURRENT.LINE + DCOUNT(CC.LIST,@AM)
*
                IF LINE.TO.MAX > LINE.TO THEN
                    LINE.TO = LINE.TO.MAX
                END ELSE
                    LINE.TO.MAX = LINE.TO
                END
*
                IF LINE.TO > DCOUNT(LINES,@AM) THEN
                    GOSUB DISPLAY.LINES
                END ELSE
                    GOSUB DISPLAY.LINES.FROM.TO
                END
*
                GOSUB DISPLAY.CC.LIST
*
            END ELSE IF CC.LIST.OPEN THEN
                CC.LIST.OPEN = FALSE
                GOSUB DISPLAY.LINES
*
            END ELSE
                GOSUB PRINT.CURRENT.LINE
            END
*
            PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE : '-- INSERT --' :
            PRINT @(X.POS,Y.POS) :
*
        END
    REPEAT
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.DELETE.CHARACTER:NULL
*
    GOSUB PUSH.HISTORY
*
    REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
    GOSUB GET.INSERT.CHAR.POS
*
    RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
    RAW.LINE.LEN = LEN(RAW.LINE)
*
    RAW.LINE = RAW.LINE[1,INSERT.CHAR.POSITION] : RAW.LINE[INSERT.CHAR.POSITION+2,9999]
    RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
    GOSUB UPDATE.LINE
*
    IF RAW.LINE.LEN < VIEW.WIDTH THEN
        GOSUB PRINT.CURRENT.LINE
    END ELSE
        GOSUB DISPLAY.LINES
    END
*
    IF X.POS # MARGIN.LEFT AND X.POS = MARGIN.LEFT + LEN(LINES<CURRENT.LINE>) THEN
        X.POS = X.POS - 1
    END
*
    PRINT @(X.POS,Y.POS) :
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
PROCESS.REPLACE.CHARACTER:NULL
*
    GOSUB PUSH.HISTORY
*
    
    $IFDEF DATABASE.UV
        CHR = KEYIN()
    $ENDIF
    $IFDEF DATABASE.D3
        INPUT CHR,0
    $ENDIF
*
    REAL.LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
    GOSUB GET.INSERT.CHAR.POS
*
    RAW.LINE = RAW.LINES<REAL.LINE.NUMBER>
    RAW.LINE[INSERT.CHAR.POSITION+1,1] = CHR
    RAW.LINES<REAL.LINE.NUMBER> = RAW.LINE
*
    GOSUB UPDATE.LINE
*
    GOSUB PRINT.CURRENT.LINE
*
    PRINT @(X.POS,Y.POS) :
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
SCROLL.UP:NULL
*
    IF CC.LIST.OPEN THEN
        IF CC.POS > 1 THEN
            CC.POS = CC.POS - 1
            GOSUB DISPLAY.CC.LIST
        END
        RETURN
    END
*
    GOSUB PRINT.CURRENT.LINE
*
    IF CURRENT.LINE = 1 THEN
        RETURN
    END
*
    IF Y.POS > MARGIN.TOP THEN
        CURRENT.LINE = CURRENT.LINE - 1
        Y.POS = Y.POS - 1
    END ELSE
        LINE.START = LINE.START - 1
        CURRENT.LINE = CURRENT.LINE - 1
        LINE = LINES<CURRENT.LINE>
        LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
*
        $IFDEF DATABASE.UV
            PRINT @(-49) :
            GOSUB PRINT.CURRENT.LINE
        $ENDIF
        $IFDEF DATABASE.D3
            GOSUB DISPLAY.LINES
        $ENDIF
    END
*
    GOSUB SET.X.POS
    GOSUB DISPLAY.HEADER
    GOSUB DISPLAY.FOOTER
    PRINT @(X.POS, Y.POS) :
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
SCROLL.DOWN:NULL
*
    IF CC.LIST.OPEN THEN
        IF CC.POS < DCOUNT(CC.LIST,@AM) THEN
            CC.POS = CC.POS + 1
            GOSUB DISPLAY.CC.LIST
        END
        RETURN
    END
*
    IF CURRENT.LINE >= DCOUNT(LINES,@AM) THEN
        RETURN
    END
*
    IF Y.POS < VIEW.HEIGHT THEN
        CURRENT.LINE = CURRENT.LINE + 1
        Y.POS = Y.POS + 1
    END ELSE
        LINE.START = LINE.START + 1
        CURRENT.LINE = CURRENT.LINE + 1
        LINE = LINES<CURRENT.LINE>
        LINE.NUMBER = LINE.NUMBERS<CURRENT.LINE>
*
        $IFDEF DATABASE.UV
            PRINT @(-48) :
            GOSUB PRINT.CURRENT.LINE
        $ENDIF
        $IFDEF DATABASE.D3
            GOSUB DISPLAY.LINES
        $ENDIF
    END
*
    GOSUB SET.X.POS
    GOSUB DISPLAY.HEADER
    PRINT @(X.POS, Y.POS) :
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
SCROLL.RIGHT:NULL
*
    IF CC.LIST.OPEN THEN
        CC.LIST.OPEN = FALSE
        GOSUB DISPLAY.LINES
    END
*
    LINE.LEN = LEN(LINES<CURRENT.LINE>)
    IF X.POS + 1 >= LINE.LEN + MARGIN.LEFT THEN
        PRINT @(X.POS, Y.POS) :
        RETURN
    END
*
    IF X.POS > SCREEN.WIDTH - MARGIN.RIGHT THEN
        PRINT @(X.POS, Y.POS) :
        RETURN
    END
*
    ORIGINAL.X.POS = 0
    X.POS = X.POS + 1
    GOSUB DISPLAY.HEADER
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
SCROLL.LEFT:NULL
*
    IF CC.LIST.OPEN THEN
        CC.LIST.OPEN = FALSE
        GOSUB DISPLAY.LINES
    END
*
    IF X.POS - 1 < MARGIN.LEFT THEN
        PRINT @(X.POS, Y.POS) :
        RETURN
    END
*
    ORIGINAL.X.POS = 0
    X.POS = X.POS - 1
    GOSUB DISPLAY.HEADER
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
SAVE.FILE:NULL
*
    IF INSIDE.VLIST THEN
        PRINT BOTTOM : CLEAR.REST.OF.LINE :
        PRINT MESSAGE.COLOR :
        PRINT 'Cannot save inside a vlist.' : CLEAR.REST.OF.LINE :
*
    END ELSE IF NEST.LEVEL # 0 THEN
        SAVE.ROW = TRUE
        GOSUB POP.EXPLODE
*
    END ELSE
        ORIGINAL.RAW.LINES = RAW.LINES
        WRITEU RAW.LINES ON FILE, RECORD.ID
*
        PRINT BOTTOM : CLEAR.REST.OF.LINE :
        PRINT MESSAGE.COLOR :
        PRINT FILENAME : ' ' : RECORD.ID : ' saved.' : CLEAR.REST.OF.LINE :
*
        PRINT @(X.POS,Y.POS) :
    END
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
COMPILE.FILE:NULL
*
    IF FILETYPE # 'BASIC' THEN RETURN
*
    $IFDEF DATABASE.UV
        EXECUTE 'BASIC ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
    $ENDIF
*
    $IFDEF DATABASE.D3
        EXECUTE 'COMPILE ' : FILENAME : ' ' : RECORD.ID CAPTURING RESULTS
    $ENDIF
*
    IF RESULTS<3> = '' THEN
        PRINT BOTTOM : MESSAGE.COLOR : CLEAR.REST.OF.LINE :
        PRINT OCONV(TIME(),'MTS') : ': ' : RESULTS<1> :
        PRINT @(X.POS,Y.POS) :
*
    END ELSE
        PRINT CLEAR.SCREEN :
        PRINT @(0,MARGIN.TOP) :
        PRINT OCONV(TIME(),'MTS') : ': ' :
        PRINT 'Error -----------------'
        PRINT
*
        FOR J = 1 TO DCOUNT(RESULTS,@AM)
            PRINT RESULTS<J>
        NEXT J
        INPUT ANYTHING :
*
        GOSUB DISPLAY.LINES
        PRINT @(X.POS,Y.POS) :
    END
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
FORMAT.FILE:NULL
*
    GOSUB PUSH.HISTORY
*
    FIRST.WORDS.INC = 'FOR,CASE,$IFDEF'
    CONVERT ',' TO @AM IN FIRST.WORDS.INC
*
    LAST.WORDS.INC = 'THEN,ELSE,LOCKED,DO,LOOP'
    CONVERT ',' TO @AM IN LAST.WORDS.INC
*
    FIRST.WORDS.DEC = 'END,WHILE,UNTIL,REPEAT,CASE,NEXT,$ENDIF'
    CONVERT ',' TO @AM IN FIRST.WORDS.DEC
*
    FMT.LINES = ''
    INDENT.LEVEL = 1
*
    NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
*
    FOR FMT.CTR = 1 TO NUMBER.OF.RAW.LINES
        TRIMMED.LINE = TRIMB(TRIMF(RAW.LINES<FMT.CTR>))
*
        IF TRIMMED.LINE[1,1] = '*' OR (INDEX(TRIMMED.LINE,':NULL',1) # 0AND INDEX(TRIMMED.LINE,'"',1) = 0 AND INDEX(TRIMMED.LINE,"'",1) = 0) THEN
            FMT.LINES<FMT.CTR> = TRIMMED.LINE
            CONTINUE
        END
*
        FIRST.WORD = FIELD(TRIMMED.LINE,' ',1)
        LAST.WORD = FIELD(TRIMMED.LINE,' ',DCOUNT(TRIMMED.LINE,' '))
*
        IF TRIMMED.LINE = 'END CASE' THEN
            INDENT.LEVEL = INDENT.LEVEL - 2
            IF INDENT.LEVEL = 0 THEN INDENT.LEVEL = 1
*
        END ELSE
            LOCATE(FIRST.WORD,FIRST.WORDS.DEC;LAST.ANYPOS) THEN
                INDENT.LEVEL = INDENT.LEVEL - 1
                IF INDENT.LEVEL = 0 THEN INDENT.LEVEL = 1
            END
        END
*
        FMT.LINE = SPACE(INDENT.LEVEL * TAB.SIZE) : TRIMMED.LINE
        FMT.LINES<FMT.CTR> = FMT.LINE
*
        LOCATE(LAST.WORD,LAST.WORDS.INC;LAST.ANYPOS) THEN
            LOCATE(FIRST.WORD,FIRST.WORDS.INC;ANYPOS) ELSE
                INDENT.LEVEL = INDENT.LEVEL + 1
            END
        END
*
        LOCATE(FIRST.WORD,FIRST.WORDS.INC;ANYPOS) THEN
            INDENT.LEVEL = INDENT.LEVEL + 1
        END
*
        IF TRIMMED.LINE = 'BEGIN CASE' THEN
            INDENT.LEVEL = INDENT.LEVEL + 2
        END
    NEXT FMT.CTR
*
    RAW.LINES = FMT.LINES
*
    GOSUB CONVERT.RAW.LINES
    GOSUB DISPLAY.LINES
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
DISPLAY.CC.LIST:NULL
*
    MAX.SHOW = DCOUNT(CC.LIST,@AM)
    IF MAX.SHOW > 5 THEN MAX.SHOW = 5
*
    FOR CC.CTR = 1 TO MAX.SHOW
        PRINT @(X.POS-CC.TRIGGER.LEN,Y.POS+CC.CTR) :
        CC.WORD = CC.LIST<CC.CTR,1>
        CC.DESCRIPTION = CC.LIST<CC.CTR,2>
        CC.STRUCTURE = CC.LIST<CC.CTR,3>
*
        IF CC.STRUCTURE = '' THEN
            CC.TYPE = ' [A] '
        END ELSE
            CC.TYPE = '~[S] '
        END
*
        IF CC.CTR = CC.POS THEN
            PRINT BACKGROUND.RED :
            PRINT RAW.WHITE :
            PRINT ' ' : CC.WORD 'L#25' : CC.TYPE
*
            PRINT BACKGROUND.BLACK
            PRINT BOTTOM : CLEAR.REST.OF.LINE : MESSAGE.COLOR :
            PRINT CC.DESCRIPTION[1,VIEW.WIDTH] :
*
        END ELSE
            PRINT BACKGROUND.CYAN :
            PRINT RAW.WHITE :
            PRINT ' ' : CC.WORD  'L#25' : CC.TYPE
        END
        PRINT RESET.COLOR :
    NEXT CC.CTR
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
ADD.CC.TOKEN:NULL
*
    IF TOKEN<1,1> = '' THEN RETURN
    IF NUM(TOKEN<1,1>) THEN RETURN
    LOCATE(TOKEN<1,1>,SNIPPET.HEADERS;TOKEN.POS) THEN
        RETURN
    END
    SNIPPETS = INSERT(SNIPPETS,TOKEN.POS;TOKEN)
    SNIPPET.HEADERS = INSERT(SNIPPET.HEADERS,TOKEN.POS;TOKEN<1,1>)
    RETURN
*
*********************  s u b r o u t i n e  *********************
*
CC.TOKENIZE.LINE:NULL
*
    IF FILETYPE = 'BASIC' THEN
        GOSUB CC.TOKENIZE.LINE.BASIC
    END ELSE IF FILETYPE = 'PROC' THEN
    END ELSE IF FILETYPE = 'DATA' THEN
    END
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
CC.TOKENIZE.LINE.BASIC:NULL
*
    TOKEN = ''
    FOR LETTER.CTR = 1 TO LEN(RAW.LINE)
        CHARACTER = RAW.LINE[LETTER.CTR,1]
*
        IF CHARACTER = ' ' THEN
            GOSUB ADD.CC.TOKEN
            TOKEN = ''
        END ELSE
            LOCATE(CHARACTER,CC.BREAK.CHARACTERS;BREAK.POS) THEN
                GOSUB ADD.CC.TOKEN
                TOKEN = ''
            END ELSE
                TOKEN = TOKEN : CHARACTER
            END
        END
    NEXT LETTER.CTR
*
    GOSUB ADD.CC.TOKEN
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
ADD.AUTO.COMPLETE:NULL
*
    NUMBER.OF.RAW.LINES = DCOUNT(RAW.LINES,@AM)
*
    FOR RAW.LINE.CTR = 1 TO NUMBER.OF.RAW.LINES
        RAW.LINE = RAW.LINES<RAW.LINE.CTR>
        GOSUB CC.TOKENIZE.LINE
    NEXT RAW.LINE.CTR
*
    RETURN
*
*********************  S U B R O U T I N E  *********************
*
ADD.SNIPPETS:NULL
*
    $IFDEF DATABASE.UV
        OPENSEQ PATH TO SNIPPETS.FILE ELSE
            RETURN
        END
*
        DONE = FALSE
        INSIDE.STRUCTURE = FALSE
*
        TOKEN = ''
        LOOP
            READSEQ SNIPPET.LINE FROM SNIPPETS.FILE ELSE
                CLOSESEQ SNIPPETS.FILE
                DONE = TRUE
            END
        UNTIL DONE DO
            IF SNIPPET.LINE[1,7] = 'snippet' THEN
                INSIDE.STRUCTURE = TRUE
                TOKEN<1,1> = FIELD(SNIPPET.LINE,' ', 2)
                TOKEN<1,2> = FIELD(SNIPPET.LINE,'"', 2)
                CONTINUE
            END
*
            IF SNIPPET.LINE[1,10] = 'endsnippet' THEN
                INSIDE.STRUCTURE = FALSE
                GOSUB ADD.CC.TOKEN
                TOKEN = ''
                CONTINUE
            END
*
            IF INSIDE.STRUCTURE THEN
                TOKEN<1,3,-1> = CHANGE(SNIPPET.LINE,'$1','')
            END
*
        REPEAT
    $ENDIF
*
    RETURN
*********************  S U B R O U T I N E  *********************
*
ADD.DEFAULT.SNIPPETS:NULL
*
    SNIPPETS<1,1> = 'ABORT'
    SNIPPETS<1,2> = 'Use the ABORT statement to terminate execution of a BASIC program and return to the UniVerse prompt.'
    SNIPPETS<1,3,1> = "ABORT "
    SNIPPETS<2,1> = 'ABS'
    SNIPPETS<2,2> = 'Use the ABS function to return the absolute value of any numeric expression.'
    SNIPPETS<2,3,1> = "ABS()"
    SNIPPETS<3,1> = 'ABSS'
    SNIPPETS<3,2> = 'Use the ABSS function to return the absolute values of all the elements in a dynamic array.'
    SNIPPETS<3,3,1> = "ABSS()"
    SNIPPETS<4,1> = 'ACOS'
    SNIPPETS<4,2> = 'Use the ACOS function to return the trigonometric arc-cosine of expression.'
    SNIPPETS<4,3,1> = "ACOS()"
    SNIPPETS<5,1> = 'ACTIVATEKEY'
    SNIPPETS<5,2> = 'Use the ACTIVATEKEY statement to activate a key.'
    SNIPPETS<5,3,1> = "ACTIVATEKEY <key.id>, <password> [ON <hostname>]"
    SNIPPETS<6,1> = 'ADDS'
    SNIPPETS<6,2> = 'Use the ADDS function to create a dynamic array of the element-by-element addition of two dynamic arrays.'
    SNIPPETS<6,3,1> = "ADDS(array1, array2)"
    SNIPPETS<7,1> = 'ALPHA'
    SNIPPETS<7,2> = 'Use the ALPHA function to determine whether expression is an alphabetic or non-alphabetic string.'
    SNIPPETS<7,3,1> = "ALPHA(expression)"
    SNIPPETS<8,1> = 'ANDS'
    SNIPPETS<8,2> = 'Use the ANDS function to create a dynamic array of the logical AND of corresponding elements of two dynamic arrays.'
    SNIPPETS<8,3,1> = "ANDS(array1, array2)"
    SNIPPETS<9,1> = 'ASCII'
    SNIPPETS<9,2> = 'Use the ASCII function to convert each character of expression from its EBCDIC representation value to its ASCII representation value.'
    SNIPPETS<9,3,1> = "ASCII(expression)"
    SNIPPETS<10,1> = 'ASIN'
    SNIPPETS<10,2> = 'Use the ASIN function to return the trigonometric arc-sine of expression.'
    SNIPPETS<10,3,1> = "ASIN(expression)"
    SNIPPETS<11,1> = 'ASSIGNED'
    SNIPPETS<11,2> = 'Use the ASSIGNED function to determine if variable is assigned a value.'
    SNIPPETS<11,3,1> = "ASSIGNED(variable)"
    SNIPPETS<12,1> = 'ATAN'
    SNIPPETS<12,2> = 'Use the ATAN function to return the trigonometric arc-tangent of expression.'
    SNIPPETS<12,3,1> = "ATAN(expression)"
    SNIPPETS<13,1> = 'AUTHORIZATION'
    SNIPPETS<13,2> = 'Use the AUTHORIZATION statement to specify or change the effective runtime user of a program.'
    SNIPPETS<13,3,1> = "AUTHORIZATION username"
    SNIPPETS<14,1> = 'AUXMAP'
    SNIPPETS<14,2> = 'In NLS mode, use the AUXMAP statement to associate an auxiliary device with a terminal.'
    SNIPPETS<14,3,1> = "AUXMAP { ON | OFF | expression }"
    SNIPPETS<15,1> = 'BITAND'
    SNIPPETS<15,2> = 'Use the BITAND function to perform the bitwise AND comparison of two integers specified by numeric expressions.'
    SNIPPETS<15,3,1> = "BITAND(expression1, expression2)"
    SNIPPETS<16,1> = 'BITNOT'
    SNIPPETS<16,2> = 'Use the BITNOT function to return the bitwise negation of an integer specified by any numeric expression.'
    SNIPPETS<16,3,1> = "BITNOT(expression [,bit#])"
    SNIPPETS<17,1> = 'BITOR'
    SNIPPETS<17,2> = 'Use the BITOR function to perform the bitwise OR comparison of two integers specified by numeric expressions.'
    SNIPPETS<17,3,1> = "BITOR(expression1, expression2)"
    SNIPPETS<18,1> = 'BITRESET'
    SNIPPETS<18,2> = 'Use the BITRESET function to reset to 0 the bit number of the integer specified by expression.'
    SNIPPETS<18,3,1> = "BITRESET(expression, bit#)"
    SNIPPETS<19,1> = 'BITSET'
    SNIPPETS<19,2> = 'Use the BITSET function to set to 1 the bit number of the integer specified by expression.'
    SNIPPETS<19,3,1> = "BITSET(expression, bit#)"
    SNIPPETS<20,1> = 'BITTEST'
    SNIPPETS<20,2> = 'Use the BITTEST function to test the bit number of the integer specified by expression.'
    SNIPPETS<20,3,1> = "BITTEST(expression, bit#)"
    SNIPPETS<21,1> = 'BITXOR'
    SNIPPETS<21,2> = 'Use the BITXOR function to perform the bitwise XOR comparison of two integers specified by numeric expressions.'
    SNIPPETS<21,3,1> = "BITXOR(expression1, expression2)"
    SNIPPETS<22,1> = 'BREAK'
    SNIPPETS<22,2> = 'Use the BREAK statement to enable or disable the Intr, Quit, and Susp keys on the keyboard.'
    SNIPPETS<22,3,1> = "BREAK [KEY] { ON | OFF | expression }"
    SNIPPETS<23,1> = 'BSCAN'
    SNIPPETS<23,2> = 'Use the BSCAN statement to scan the leaf nodes of a B-tree file (type 25) or of a secondary index.'
    SNIPPETS<23,3,1> = "BSCAN ID.variable [, rec.variable] [FROM file.variable [, record]]"
    SNIPPETS<24,1> = 'BYTE'
    SNIPPETS<24,2> = 'In NLS mode, use the BYTE function to generate a byte from the numeric value of expression.'
    SNIPPETS<24,3,1> = "BYTE(expression)"
    SNIPPETS<25,1> = 'BYTELEN'
    SNIPPETS<25,2> = 'In NLS mode, use the BYTELEN function to generate the number of bytes contained in the ASCII string value in expression.'
    SNIPPETS<25,3,1> = "BYTELEN(expression)"
    SNIPPETS<26,1> = 'BYTETYPE'
    SNIPPETS<26,2> = 'In NLS mode, use the BYTETYPE function to determine the function of a byte in value.'
    SNIPPETS<26,3,1> = "BYTETYPE(value)"
    SNIPPETS<27,1> = 'BYTEVAL'
    SNIPPETS<27,2> = 'In NLS mode, use the BYTEVAL function to examine the bytes contained in the internal string value of expression.'
    SNIPPETS<27,3,1> = "BYTEVAL(expression [, n] )"
    SNIPPETS<28,1> = 'CALL'
    SNIPPETS<28,2> = 'Use the CALL statement to transfer program control from the calling program to an external subroutine or program that has been compiled and cataloged.'
    SNIPPETS<28,3,1> = "CALL name [([MAT] argument [, [MAT] argument ])]"
    SNIPPETS<29,1> = 'CASE'
    SNIPPETS<29,2> = 'Use the CASE statement to alter the sequence of instruction execution based on the value of one or more expressions.'
    SNIPPETS<29,3,1> = "BEGIN CASE"
    SNIPPETS<30,1> = 'CATS'
    SNIPPETS<30,2> = 'Use the CATS function to create a dynamic array of the element-by-element concatenation of two dynamic arrays.'
    SNIPPETS<30,3,1> = "CATS(array1, array2)"
    SNIPPETS<31,1> = 'CHAIN'
    SNIPPETS<31,2> = 'Use the CHAIN statement to terminate execution of a UniVerse BASIC program and to execute the value of command.'
    SNIPPETS<31,3,1> = "CHAIN command"
    SNIPPETS<32,1> = 'CHANGE'
    SNIPPETS<32,2> = 'Use the CHANGE function to replace a substring in expression with another substring.'
    SNIPPETS<32,3,1> = "CHANGE(expression, substring, replacement [,occurrence [,begin]] )"
    SNIPPETS<33,1> = 'CHAR'
    SNIPPETS<33,2> = 'Use the CHAR function to generate an ASCII character from the numeric value of expression.'
    SNIPPETS<33,3,1> = "CHAR(expression)"
    SNIPPETS<34,1> = 'CHARS'
    SNIPPETS<34,2> = 'Use the CHARS function to generate a dynamic array of ASCII characters from the decimal numeric value of each element of dynamic.'
    SNIPPETS<34,3,1> = "CHARS(dynamic.array)"
    SNIPPETS<35,1> = 'CHECKSUM'
    SNIPPETS<35,2> = 'Use the CHECKSUM function to return a cyclical redundancy code (a checksum value).'
    SNIPPETS<35,3,1> = "CHECKSUM(string)"
    SNIPPETS<36,1> = 'CLEAR'
    SNIPPETS<36,2> = 'Use the CLEAR statement at the beginning of a program to set all assigned and unassigned values of variables outside of the common area of the program to 0.'
    SNIPPETS<36,3,1> = "CLEAR [COMMON]"
    SNIPPETS<37,1> = 'CLEARDATA'
    SNIPPETS<37,2> = 'Use the CLEARDATA statement to flush all data that has been loaded in the input stack by the DATA statement.'
    SNIPPETS<37,3,1> = "CLEARDATA"
    SNIPPETS<38,1> = 'CLEARFILE'
    SNIPPETS<38,2> = 'Use the CLEARFILE statement to delete all records in an open dictionary or data file.'
    SNIPPETS<38,3,1> = "CLEARFILE [file.variable] [ON ERROR statements] [LOCKED statements]"
    SNIPPETS<39,1> = 'CLEARPROMPTS'
    SNIPPETS<39,2> = 'Use the CLEARPROMPTS statement to clear the value of the inline prompt.'
    SNIPPETS<39,3,1> = "CLEARPROMPTS"
    SNIPPETS<40,1> = 'CLEARSELECT'
    SNIPPETS<40,2> = 'Use the CLEARSELECT statement to clear an active select list.'
    SNIPPETS<40,3,1> = "CLEARSELECT [ALL | list.number]"
    SNIPPETS<41,1> = 'CLOSE'
    SNIPPETS<41,2> = 'Use the CLOSE statement after opening and processing a file.'
    SNIPPETS<41,3,1> = "CLOSE [file.variable] [ON ERROR statements]"
    SNIPPETS<42,1> = 'CLOSESEQ'
    SNIPPETS<42,2> = 'Use the CLOSESEQ statement after opening and processing a file opened for sequential processing.'
    SNIPPETS<42,3,1> = "CLOSESEQ file.variable [ON ERROR statements]"
    SNIPPETS<43,1> = 'COMMIT'
    SNIPPETS<43,2> = 'Use the COMMIT statement to commit all file I/O changes made during a transaction.'
    SNIPPETS<43,3,1> = "COMMIT [WORK] [THEN statements] [ELSE statements ]"
    SNIPPETS<44,1> = 'COMMON'
    SNIPPETS<44,2> = 'Use the COMMON statement to provide a storage area for variables.'
    SNIPPETS<44,3,1> = "COM[MON] [/name/] variable [,variable ]"
    SNIPPETS<45,1> = 'COMPARE'
    SNIPPETS<45,2> = 'Use the COMPARE function to compare two strings and return a numeric value indicating the result.'
    SNIPPETS<45,3,1> = "COMPARE(string1, string2 [, justification])"
    SNIPPETS<46,1> = 'CONVERT'
    SNIPPETS<46,2> = 'Use the CONVERT statement to replace every occurrence of specific characters in a string with other characters.'
    SNIPPETS<46,3,1> = "CONVERT expression1 TO expression2 IN variable"
    SNIPPETS<47,1> = 'COS'
    SNIPPETS<47,2> = 'Use the COS function to return the trigonometric cosine of an angle.'
    SNIPPETS<47,3,1> = "COS(expression)"
    SNIPPETS<48,1> = 'COSH'
    SNIPPETS<48,2> = 'Use the COSH function to return the hyperbolic cosine of expression.'
    SNIPPETS<48,3,1> = "COSH(expression)"
    SNIPPETS<49,1> = 'COUNT'
    SNIPPETS<49,2> = 'Use the COUNT function to return the number of times a substring is repeated in a string value.'
    SNIPPETS<49,3,1> = "COUNT(string, substring)"
    SNIPPETS<50,1> = 'COUNTS'
    SNIPPETS<50,2> = 'Use the COUNTS function to count the number of times a substring is repeated in each element of a dynamic array.'
    SNIPPETS<50,3,1> = "COUNTS(dynamic.array, substring)"
    SNIPPETS<51,1> = 'CREATE'
    SNIPPETS<51,2> = 'Use the CREATE statement after an OPENSEQ statement to create a record in a type 1 or type statement fails.'
    SNIPPETS<51,3,1> = "CREATE file.variable {THEN statements [ELSE statements] | ELSE"
    SNIPPETS<52,1> = 'CRT'
    SNIPPETS<52,2> = 'Use the CRT statement to print data on the screen, regardless of whether a PRINTER ON statement has been executed.'
    SNIPPETS<52,3,1> = "CRT [print.list]"
    SNIPPETS<53,1> = 'DATA'
    SNIPPETS<53,2> = 'Use the DATA statement to place values in an input stack.'
    SNIPPETS<53,3,1> = "DATA expression [,expression ]"
    SNIPPETS<54,1> = 'DATE'
    SNIPPETS<54,2> = 'Use the DATE function to return the numeric value of the internal system date.'
    SNIPPETS<54,3,1> = "DATE()"
    SNIPPETS<55,1> = 'DBTOXML'
    SNIPPETS<55,2> = 'To create an XML document from the UniVerse database using UniVerse BASIC, use the DBTOXML function.'
    SNIPPETS<55,3,1> = "DBTOXML(xml_document, doc_location, u2xmap_file, u2xmap_location,"
    SNIPPETS<56,1> = 'DCOUNT'
    SNIPPETS<56,2> = 'Use the DCOUNT function to return the number of delimited fields in a data string.'
    SNIPPETS<56,3,1> = "DCOUNT(string, delimiter)"
    SNIPPETS<57,1> = 'DEACTIVATEKEY'
    SNIPPETS<57,2> = 'Use the DEACTIVATEKEY command to deactivate one or more encryption keys.'
    SNIPPETS<57,3,1> = "DEACTIVATEKEY <key.id>, <password> [ON <hostname>]"
    SNIPPETS<58,1> = 'DEBUG'
    SNIPPETS<58,2> = 'Use the DEBUG statement to invoke RAID, the interactive UniVerse BASIC debugger.'
    SNIPPETS<58,3,1> = "DEBUG"
    SNIPPETS<59,1> = 'DEFFUN'
    SNIPPETS<59,2> = 'Use the DEFFUN statement to define a user-written function.'
    SNIPPETS<59,3,1> = "DEFFUN function [([MAT] argument [, [MAT] argument ] )] [CALLING"
    SNIPPETS<60,1> = 'DEL'
    SNIPPETS<60,2> = 'Use the DEL statement to delete a field, value, or subvalue from a dynamic array.'
    SNIPPETS<60,3,1> = "DEL dynamic.array < field# [,value# [,subvalue#]] >"
    SNIPPETS<61,1> = 'DELETE'
    SNIPPETS<61,2> = 'Use the DELETE statements to delete a record from a UniVerse file.'
    SNIPPETS<61,3,1> = "DELETE [file.variable ,] record.ID [ON ERROR statements] [LOCKED"
    SNIPPETS<62,1> = 'DELETELIST'
    SNIPPETS<62,2> = 'Use the DELETELIST statement to delete a select list saved in the &SAVEDLISTS& file.'
    SNIPPETS<62,3,1> = "DELETELIST listname"
    SNIPPETS<63,1> = 'DESCRINFO'
    SNIPPETS<63,2> = 'The DESCRINFO function returns requested information (key) about a variable.'
    SNIPPETS<63,3,1> = "DESCRINFO(key, variable)"
    SNIPPETS<64,1> = 'DIGEST'
    SNIPPETS<64,2> = 'The DIGEST() function generates a message digest of supplied data.'
    SNIPPETS<64,3,1> = "DIGEST(algorithm, data, dataLoc, result)"
    SNIPPETS<65,1> = 'DIMENSION'
    SNIPPETS<65,2> = 'Use the DIMENSION statement to define the dimensions of an array variable before referencing the array in the program.'
    SNIPPETS<65,3,1> = "DIM[ENSION] matrix(rows, columns) [, matrix(rows, columns) ]"
    SNIPPETS<66,1> = 'DISABLEDEC'
    SNIPPETS<66,2> = 'Use the DISABLEDEC command to turn off decryption on a field or fields you specify.'
    SNIPPETS<66,3,1> = "DISABLEDEC <filename> [, <multilevel-filename>], {ALL |<field_list>}"
    SNIPPETS<67,1> = 'DISPLAY'
    SNIPPETS<67,2> = 'Use the DISPLAY statement to print data on the screen, regardless of whether a PRINTER ON statement has been executed.'
    SNIPPETS<67,3,1> = "DISPLAY [print.list]"
    SNIPPETS<68,1> = 'DIV'
    SNIPPETS<68,2> = 'Use the DIV function to calculate the value of the quotient after dividend is divided by divisor.'
    SNIPPETS<68,3,1> = "DIV(dividend, divisor)"
    SNIPPETS<69,1> = 'DIVS'
    SNIPPETS<69,2> = 'Use the DIVS function to create a dynamic array containing the result of the element-by-element division of two dynamic arrays.'
    SNIPPETS<69,3,1> = "DIVS(array1, array2)"
    SNIPPETS<70,1> = 'DOWNCASE'
    SNIPPETS<70,2> = 'Use the DOWNCASE function to change all uppercase letters in expression to lowercase.'
    SNIPPETS<70,3,1> = "DOWNCASE(expression)"
    SNIPPETS<71,1> = 'DQUOTE'
    SNIPPETS<71,2> = 'Use the DQUOTE function to enclose an expression in double quotation marks.'
    SNIPPETS<71,3,1> = "DQUOTE(expression)"
    SNIPPETS<72,1> = 'DTX'
    SNIPPETS<72,2> = 'Use the DTX function to convert a decimal integer to its hexadecimal equivalent.'
    SNIPPETS<72,3,1> = "DTX(number [,size] )"
    SNIPPETS<73,1> = 'EBCDIC'
    SNIPPETS<73,2> = 'Use the EBCDIC function to convert each character of expression from its ASCII representation value to its EBCDIC representation value.'
    SNIPPETS<73,3,1> = "EBCDIC(expression)"
    SNIPPETS<74,1> = 'ECHO'
    SNIPPETS<74,2> = 'Use the ECHO statement to control the display of input characters on the screen.'
    SNIPPETS<74,3,1> = "ECHO {ON | OFF | expression}"
    SNIPPETS<75,1> = 'ENABLEDEC'
    SNIPPETS<75,2> = 'Use the ENABLEDEC command to activate decryption on a file or fields you specify.'
    SNIPPETS<75,3,1> = "ENABLEDEC <filename> [, <multilevel-filename>], { ALL |<field_list>}"
    SNIPPETS<76,1> = 'ENCODE'
    SNIPPETS<76,2> = 'The ENCODE() function performs data encoding on input data.'
    SNIPPETS<76,3,1> = "ENCODE(algorithm, action, data, dataLoc, result, resultLoc)"
    SNIPPETS<77,1> = 'ENCRYPT'
    SNIPPETS<77,2> = 'The ENCRYPT() function performs symmetric encryption operations.'
    SNIPPETS<77,3,1> = "ENCRYPT(algorithm, action, data, dataLoc,key, keyLoc, keyAction, salt,"
    SNIPPETS<78,1> = 'END'
    SNIPPETS<78,2> = 'Use the END statement to terminate a BASIC program or a section of an IF statement, READ statement, or OPEN statement.'
    SNIPPETS<78,3,1> = "END"
    SNIPPETS<79,1> = 'ENTER'
    SNIPPETS<79,2> = 'Use the ENTER statement to transfer program control from the calling program to an external subroutine without returning to the calling program.'
    SNIPPETS<79,3,1> = "ENTER subroutine"
    SNIPPETS<80,1> = 'EQS'
    SNIPPETS<80,2> = 'Use the EQS function to test if elements of one dynamic array are equal to the elements of another dynamic array.'
    SNIPPETS<80,3,1> = "EQS(array1, array2)"
    SNIPPETS<81,1> = 'EQUATE'
    SNIPPETS<81,2> = 'In an EQUATE statement, symbol represents the value of expression or string.'
    SNIPPETS<81,3,1> = "EQU[ATE] symbol TO expression [,symbol TO expression ]"
    SNIPPETS<82,1> = 'EREPLACE'
    SNIPPETS<82,2> = 'Use the EREPLACE function to replace substring in expression with another substring.'
    SNIPPETS<82,3,1> = "EREPLACE(expression, substring, replacement [,occurrence [,begin]] )"
    SNIPPETS<83,1> = 'ERRMSG'
    SNIPPETS<83,2> = 'Use the ERRMSG statement to print a formatted error message from the ERRMSG file.'
    SNIPPETS<83,3,1> = "ERRMSG message.ID [,message.ID ]"
    SNIPPETS<84,1> = 'EXCHANGE'
    SNIPPETS<84,2> = 'Use the EXCHANGE function to replace one character with another or to delete all occurrences of the specified character.'
    SNIPPETS<84,3,1> = "EXCHANGE(string, xx, yy)"
    SNIPPETS<85,1> = 'EXECUTE'
    SNIPPETS<85,2> = 'Use the EXECUTE statement to execute UniVerse commands from within the BASIC program and then return execution to the statement following the EXECUTE statement.'
    SNIPPETS<85,3,1> = "EXECUTE  CAPTURING RESULTS"
    SNIPPETS<86,1> = 'EXIT'
    SNIPPETS<86,2> = 'Use the EXIT statement to quit execution of a FOR.'
    SNIPPETS<86,3,1> = "EXIT"
    SNIPPETS<87,1> = 'EXP'
    SNIPPETS<87,2> = 'Use the EXP function to return the value of e raised to the power designated by expression.'
    SNIPPETS<87,3,1> = "EXP(expression)"
    SNIPPETS<88,1> = 'EXTRACT'
    SNIPPETS<88,2> = 'Use the EXTRACT function to access the data contents of a specified field, value, or subvalue from a dynamic array.'
    SNIPPETS<88,3,1> = "EXTRACT(dynamic.array, field#[,value# [,subvalue#]] )"
    SNIPPETS<89,1> = 'FADD'
    SNIPPETS<89,2> = 'Use the FADD function to perform floating-point addition on two numeric values.'
    SNIPPETS<89,3,1> = "CALL !FADD(return.array, number1, number2)"
    SNIPPETS<90,1> = 'FDIV'
    SNIPPETS<90,2> = 'Use the FDIV function to perform floating-point division on two numeric values.'
    SNIPPETS<90,3,1> = "FDIV(number1, number2)"
    SNIPPETS<91,1> = 'FFIX'
    SNIPPETS<91,2> = 'Use the FFIX function to convert a floating-point number to a numeric string with fixed precision.'
    SNIPPETS<91,3,1> = "FFIX(number)"
    SNIPPETS<92,1> = 'FFLT'
    SNIPPETS<92,2> = 'Use the FFLT function to round a number to a string with a precision of 13.'
    SNIPPETS<92,3,1> = "FFLT(number)"
    SNIPPETS<93,1> = 'FIELD'
    SNIPPETS<93,2> = 'Use the FIELD function to return one or more substrings located between specified delimiters in string.'
    SNIPPETS<93,3,1> = "FIELD(string, delimiter, occurrence [,num.substr] )"
    SNIPPETS<94,1> = 'FIELDS'
    SNIPPETS<94,2> = 'Use the FIELDS function to return a dynamic array of substrings located between specified delimiters in each element of dynamic.'
    SNIPPETS<94,3,1> = "FIELDS(dynamic.array, delimiter, occurrence [ ,num.substr] )"
    SNIPPETS<95,1> = 'FIELDSTORE'
    SNIPPETS<95,2> = 'Use the FIELDSTORE function to modify character strings by inserting, deleting, or replacing fields separated by specified delimiters.'
    SNIPPETS<95,3,1> = "FIELDSTORE(string, delimiter, start, n, new.string)"
    SNIPPETS<96,1> = 'FIELDWRITE'
    SNIPPETS<96,2> = 'The FIELDWRITE statement allows you to update the specified fields in an existing record and releases locks set by the same process.'
    SNIPPETS<96,3,1> = "FIELDWRITE[U] expression {ON | TO} [file.variable,] record.ID,"
    SNIPPETS<97,1> = 'FILEINFO'
    SNIPPETS<97,2> = 'Use the FILEINFO function to return information about the specified files configuration, such as the specified files parameters, its modulus and load, its operating system file name, and its VOC name.'
    SNIPPETS<97,3,1> = "FILEINFO(file.variable , key )"
    SNIPPETS<98,1> = 'FILELOCK'
    SNIPPETS<98,2> = 'Use the FILELOCK statement to acquire a lock on an entire file.'
    SNIPPETS<98,3,1> = "FILELOCK [file.variable] [, lock.type] [ON ERROR statements] [LOCKED"
    SNIPPETS<99,1> = 'FILEUNLOCK'
    SNIPPETS<99,2> = 'Use the FILEUNLOCK statement to release a file lock set by the FILELOCK statement.'
    SNIPPETS<99,3,1> = "FILEUNLOCK [file.variable] [ON ERROR statements]"
    SNIPPETS<100,1> = 'FIND'
    SNIPPETS<100,2> = 'Use the FIND statement to locate an element in dynamic.'
    SNIPPETS<100,3,1> = "FINDelement IN dynamic.array [,occurrence] SETTING fmc [,vmc [,smc]]"
    SNIPPETS<101,1> = 'FINDSTR'
    SNIPPETS<101,2> = 'Use the FINDSTR statement to locate substring in dynamic.'
    SNIPPETS<101,3,1> = "FINDSTRsubstring IN dynamic.array [,occurrence] SETTING fmc [,vmc"
    SNIPPETS<102,1> = 'FIX'
    SNIPPETS<102,2> = 'Use the FIX function to convert a numeric value to a floating-point number with a specified precision.'
    SNIPPETS<102,3,1> = "FIX(number [,precision [,mode]] )"
    SNIPPETS<103,1> = 'FLUSH'
    SNIPPETS<103,2> = 'The FLUSH statement causes all the buffers for a sequential I/O file to be written immediately.'
    SNIPPETS<103,3,1> = "FLUSH file.variable {THEN statements [ELSE statements] | ELSE"
    SNIPPETS<104,1> = 'FMT'
    SNIPPETS<104,2> = 'Use the FMT function or a format expression to format data for output.'
    SNIPPETS<104,3,1> = "FMT(expression, format)expressionformat"
    SNIPPETS<105,1> = 'FMTDP'
    SNIPPETS<105,2> = 'In NLS mode, use the FMTDP function to format data for output in display positions rather than character lengths.'
    SNIPPETS<105,3,1> = "FMTDP(expression, format [, mapname ] )"
    SNIPPETS<106,1> = 'FMTS'
    SNIPPETS<106,2> = 'Use the FMTS function to format elements of dynamic.'
    SNIPPETS<106,3,1> = "FMTS(dynamic.array, format)"
    SNIPPETS<107,1> = 'FMTSDP'
    SNIPPETS<107,2> = 'In NLS mode, use the FMTSDP function to format elements of dynamic.'
    SNIPPETS<107,3,1> = "FMTSDP(dynamic.array, format [, mapname] )"
    SNIPPETS<108,1> = 'FMUL'
    SNIPPETS<108,2> = 'Use the FMUL function to perform floating-point multiplication on two numeric values.'
    SNIPPETS<108,3,1> = "FMUL(number1, number2)"
    SNIPPETS<109,1> = 'FOLD'
    SNIPPETS<109,2> = 'Use the FOLD function to divide a string into a number of substrings separated by field marks.'
    SNIPPETS<109,3,1> = "FOLD(string, length )"
    SNIPPETS<110,1> = 'FOLDDP'
    SNIPPETS<110,2> = 'In NLS mode, use the FOLDDP function to divide a string into a number of substrings separated by field marks.'
    SNIPPETS<110,3,1> = "FOLDDP(string, length [, mapname ] )"
    SNIPPETS<111,1> = 'FOOTING'
    SNIPPETS<111,2> = 'Use the FOOTING statement to specify the text and format of the footing to print at the bottom of each page of output.'
    SNIPPETS<111,3,1> = "FOOTING [ON print.channel] footing"
    SNIPPETS<112,1> = 'FOR'
    SNIPPETS<112,2> = 'Use the FOR statement to create a FORNEXT program loop.'
    SNIPPETS<112,3,1> = "FOR I = 1 TO DCOUNT(,@VM)"
    SNIPPETS<112,3,2> = "NEXT I"
    SNIPPETS<113,1> = 'FORMLIST'
    SNIPPETS<113,2> = 'The FORMLIST statement is the same as the SELECT statements.'
    SNIPPETS<113,3,1> = "FORMLIST "
    SNIPPETS<114,1> = 'FSUB'
    SNIPPETS<114,2> = 'Use the FSUB function to perform floating-point subtraction on two numeric values.'
    SNIPPETS<114,3,1> = "FSUB(, )"
    SNIPPETS<115,1> = 'FUNCTION'
    SNIPPETS<115,2> = 'Use the FUNCTION statement to identify a user-written function and to specify the number and names of the arguments to be passed to it.'
    SNIPPETS<115,3,1> = "FUNCTION [name] [( [MAT] variable [, [MAT] variable ] )]"
    SNIPPETS<116,1> = 'GES'
    SNIPPETS<116,2> = 'Use the GES function to test if elements of one dynamic array are greater than or equal to corresponding elements of another dynamic array.'
    SNIPPETS<116,3,1> = "GES(array1, array2)"
    SNIPPETS<117,1> = 'GET'
    SNIPPETS<117,2> = 'Use GET statements to read a block of data from an input stream associated with a device, such as a serial line or terminal.'
    SNIPPETS<117,3,1> = "GET[X]read.var[, length] [SETTING read.count] FROM device [UNTIL"
    SNIPPETS<118,1> = 'GETX'
    SNIPPETS<118,2> = 'Use the GETX statement to read a block of data from an input stream and return the characters in ASCII hexadecimal format.'
    SNIPPETS<118,3,1> = "GET(ARG. [,arg#] ) variable [THEN statements] [ELSE statements]"
    SNIPPETS<119,1> = 'GETLIST'
    SNIPPETS<119,2> = 'Use the GETLIST statement to activate a saved select list so that a READNEXT statement can use it.'
    SNIPPETS<119,3,1> = "GETLIST listname [IN start, end] [TO list.number] [SETTING variable]"
    SNIPPETS<120,1> = 'GETLOCALE'
    SNIPPETS<120,2> = 'In NLS mode use the GETLOCALE function to return the names of specified categories of the current locale.'
    SNIPPETS<120,3,1> = "GETLOCALE(category)"
    SNIPPETS<121,1> = 'GETREM'
    SNIPPETS<121,2> = 'Use the GETREM function after the execution of a REMOVE statement, a REMOVE function, or a REVREMOVE statement, to return the numeric value for the character position of the pointer associated with dynamic.'
    SNIPPETS<121,3,1> = "GETREM(dynamic.array)"
    SNIPPETS<122,1> = 'GOSUB'
    SNIPPETS<122,2> = 'Use the GOSUB statement to transfer program control to an internal subroutine referenced by statement.'
    SNIPPETS<122,3,1> = "GOSUB "
    SNIPPETS<123,1> = 'GOTO'
    SNIPPETS<123,2> = 'Use the GOTO statement to transfer program control to the statement specified by statement.'
    SNIPPETS<123,3,1> = "GO[TO] statement.label [:]"
    SNIPPETS<124,1> = 'GROUP'
    SNIPPETS<124,2> = 'Use the GROUP function to return one or more substrings located between specified delimiters in string.'
    SNIPPETS<124,3,1> = "GROUP(string, delimiter, occurrence [,num.substr] )"
    SNIPPETS<125,1> = 'GROUPSTORE'
    SNIPPETS<125,2> = 'Use the GROUPSTORE statement to modify character strings by inserting, deleting, or replacing fields separated by specified delimiters.'
    SNIPPETS<125,3,1> = "GROUPSTORE new.string IN string USING start, n [ ,delimiter]"
    SNIPPETS<126,1> = 'GTS'
    SNIPPETS<126,2> = 'Use the GTS function to test if elements of one dynamic array are greater than elements of another dynamic array.'
    SNIPPETS<126,3,1> = "GTS(array1, array2)"
    SNIPPETS<127,1> = 'HEADING'
    SNIPPETS<127,2> = 'Use the HEADING statement to specify the text and format of the heading to print at the top of each page of output.'
    SNIPPETS<127,3,1> = "HEADING [ON print.channel] heading"
    SNIPPETS<128,1> = 'HMAC'
    SNIPPETS<128,2> = 'HMAC (keyed-Hash Message Authentication Code) is a specific construction for calculating a message authentication code (MAC) involving a cryptographic hash function in combination with a secret key.'
    SNIPPETS<128,3,1> = "hmac= HMAC(hmacAlg, hmacKey, hmacData, [outFormat])"
    SNIPPETS<129,1> = 'HUSH'
    SNIPPETS<129,2> = 'Use the HUSH statement to suppress the display of all output normally sent to a terminal during processing.'
    SNIPPETS<129,3,1> = "HUSH { ON | OFF | expression} [SETTING status ]"
    SNIPPETS<130,1> = 'ICHECK'
    SNIPPETS<130,2> = 'Use the ICHECK function to check if data you intend to write to an SQL table violates any SQL integrity constraints.'
    SNIPPETS<130,3,1> = "ICHECK(dynamic.array [, file.variable] , key [, column#] )"
    SNIPPETS<131,1> = 'ICONV'
    SNIPPETS<131,2> = 'Use the ICONV function to convert string to a specified internal storage format.'
    SNIPPETS<131,3,1> = "ICONV(, "")"
    SNIPPETS<132,1> = 'ICONVS'
    SNIPPETS<132,2> = 'Use the ICONVS function to convert each element of dynamic.'
    SNIPPETS<132,3,1> = "ICONVS(, "")"
    SNIPPETS<133,1> = 'IF'
    SNIPPETS<133,2> = 'Use the IF statement to determine program flow based on the evaluation of expression.'
    SNIPPETS<133,3,1> = "IF  THEN"
    SNIPPETS<133,3,2> = "END"
    SNIPPETS<134,1> = 'IFS'
    SNIPPETS<134,2> = 'Use the IFS function to return a dynamic array whose elements are chosen individually from one of two dynamic arrays based on the contents of a third dynamic array.'
    SNIPPETS<134,3,1> = "IFS(dynamic.array, true.array, false.array)"
    SNIPPETS<135,1> = 'ILPROMPT'
    SNIPPETS<135,2> = 'Use the ILPROMPT function to evaluate a string containing UniVerse in-line prompts.'
    SNIPPETS<135,3,1> = "ILPROMPT(in.line.prompt)"
    SNIPPETS<136,1> = 'INCLUDE'
    SNIPPETS<136,2> = 'Use the INCLUDE statement to direct the compiler to insert the source code in the record program and compile it along with the main program.'
    SNIPPETS<136,3,1> = "INCLUDE [filename] program"
    SNIPPETS<137,1> = 'INDEX'
    SNIPPETS<137,2> = 'Use the INDEX function to return the starting character position for the specified occurrence of substring in string.'
    SNIPPETS<137,3,1> = "INDEX(string, substring, occurrence)"
    SNIPPETS<138,1> = 'INDEXS'
    SNIPPETS<138,2> = 'Use the INDEXS function to return a dynamic array of the starting column positions for a specified occurrence of a substring in each element of dynamic.'
    SNIPPETS<138,3,1> = "INDEXS(dynamic.array, substring, occurrence)"
    SNIPPETS<139,1> = 'INDICES'
    SNIPPETS<139,2> = 'Use the INDICES function to return information about the secondary key indexes in a file.'
    SNIPPETS<139,3,1> = "INDICES(file.variable [,indexname])"
    SNIPPETS<140,1> = 'INMAT'
    SNIPPETS<140,2> = 'Use the INMAT function to return the number of array elements that have been loaded after the execution of MATREAD statements, MATREADL statement, MATREADU statement, or MATPARSE statement, or to return the modulo of a file after the execution of an OPEN statement.'
    SNIPPETS<140,3,1> = "INMAT([array] )"
    SNIPPETS<141,1> = 'INPUT'
    SNIPPETS<141,2> = 'Use the INPUT statement to halt program execution and prompt the user to enter a response.'
    SNIPPETS<141,3,1> = "INPUT variable [,length] [:] [_] [{WAITING} time.expr]"
    SNIPPETS<142,1> = 'INPUTCLEAR'
    SNIPPETS<142,2> = 'Use the INPUTCLEAR statement to clear the type-ahead buffer.'
    SNIPPETS<142,3,1> = "INPUTCLEAR"
    SNIPPETS<143,1> = 'INPUTDISP'
    SNIPPETS<143,2> = 'Use the INPUTDISP statement with an @ expression to position the cursor at a specified location and define a format for the variable to print.'
    SNIPPETS<143,3,1> = "INPUTDISP [@(col, row) [, | :]] variable [format]"
    SNIPPETS<144,1> = 'INPUTDP'
    SNIPPETS<144,2> = 'In NLS mode, use the INPUTDP statement to let the user enter data.'
    SNIPPETS<144,3,1> = "INPUTDP variable [, length] [:] [_] [THEN statements] [ELSE statements]"
    SNIPPETS<145,1> = 'INPUTERR'
    SNIPPETS<145,2> = 'Use the INPUTERR statement to print a formatted error message on the bottom line of the terminal.'
    SNIPPETS<145,3,1> = "INPUTERR [error.message]"
    SNIPPETS<146,1> = 'INPUTNULL'
    SNIPPETS<146,2> = 'Use the INPUTNULL statement to define a character to be recognized as an empty string when it is input in response to an INPUT statement.'
    SNIPPETS<146,3,1> = "INPUTNULL character"
    SNIPPETS<147,1> = 'INPUTTRAP'
    SNIPPETS<147,2> = 'Use the INPUTTRAP statement to branch to a program label or subroutine when a trap character is input.'
    SNIPPETS<147,3,1> = "INPUTTRAP [trap.chars] {GOTO | GOSUB} label [ ,label ]"
    SNIPPETS<148,1> = 'INS'
    SNIPPETS<148,2> = 'Use the INS statement to insert a new field, value, or subvalue into the specified dynamic.'
    SNIPPETS<148,3,1> = "INS expression BEFORE dynamic.array < field# [,value# [ ,subvalue#]] >"
    SNIPPETS<149,1> = 'INSERT'
    SNIPPETS<149,2> = 'Use the INSERT function to return a dynamic array that has a new field, value, or subvalue inserted into the specified dynamic array.'
    SNIPPETS<149,3,1> = "INSERT(dynamic.array, field#, value#, subvalue#, expression)"
    SNIPPETS<150,1> = 'INT'
    SNIPPETS<150,2> = 'Use the INT function to return the integer portion of an expression.'
    SNIPPETS<150,3,1> = "INT(expression)"
    SNIPPETS<151,1> = 'ISNULL'
    SNIPPETS<151,2> = 'Use the ISNULL function to test whether a variable is the null value.'
    SNIPPETS<151,3,1> = "ISNULL(variable)"
    SNIPPETS<152,1> = 'ISNULLS'
    SNIPPETS<152,2> = 'Use the ISNULLS function to test whether any element of dynamic.'
    SNIPPETS<152,3,1> = "ISNULLS(dynamic.array)"
    SNIPPETS<153,1> = 'ITYPE'
    SNIPPETS<153,2> = 'The ITYPE function leverages the object code stored within a compiled i.'
    SNIPPETS<153,3,1> = "ITYPE(item)"
    SNIPPETS<154,1> = 'KEYEDIT'
    SNIPPETS<154,2> = 'Use the KEYEDIT statement to assign specific keyboard keys to the editing functions of the INPUT @ statement, and to the !EDIT.'
    SNIPPETS<154,3,1> = "KEYEDIT(function, key) [,(function, key)]"
    SNIPPETS<155,1> = 'KEYEXIT'
    SNIPPETS<155,2> = 'Use the KEYEXIT statement to specify exit traps for the keys assigned specific functions by the KEYEDIT statement.'
    SNIPPETS<155,3,1> = "KEYEXIT(value, key) [,(value, key)]"
    SNIPPETS<156,1> = 'KEYIN'
    SNIPPETS<156,2> = 'Use the KEYIN function to read a single character from the input buffer and return it.'
    SNIPPETS<156,3,1> = "KEYIN()"
    SNIPPETS<157,1> = 'KEYTRAP'
    SNIPPETS<157,2> = 'Use the KEYTRAP statement to specify traps for the keys assigned specific functions by the KEYEDIT statement.'
    SNIPPETS<157,3,1> = "KEYTRAP(value, key) [,(value, key)]"
    SNIPPETS<158,1> = 'LEFT'
    SNIPPETS<158,2> = 'Use the LEFT function to extract a substring comprising the first n characters of a string, without specifying the starting character position.'
    SNIPPETS<158,3,1> = "LEFT(string, n)"
    SNIPPETS<159,1> = 'LEN'
    SNIPPETS<159,2> = 'Use the LEN function to return the number of characters in string.'
    SNIPPETS<159,3,1> = "LEN(string)"
    SNIPPETS<160,1> = 'LENDP'
    SNIPPETS<160,2> = 'In NLS mode, use the LENDP function to return the number of display positions occupied by string when using the specified map.'
    SNIPPETS<160,3,1> = "LENDP(string [,mapname] )"
    SNIPPETS<161,1> = 'LENS'
    SNIPPETS<161,2> = 'Use the LENS function to return a dynamic array of the number of display positions in each element of dynamic.'
    SNIPPETS<161,3,1> = "LENS(dynamic.array)"
    SNIPPETS<162,1> = 'LENSDP'
    SNIPPETS<162,2> = 'In NLS mode, use the LENSDP function to return a dynamic array of the number of display positions occupied by each element of dynamic.'
    SNIPPETS<162,3,1> = "LENSDP(dynamic.array [, mapname] )"
    SNIPPETS<163,1> = 'LES'
    SNIPPETS<163,2> = 'Use the LES function to test if elements of one dynamic array are less than or equal to the elements of another dynamic array.'
    SNIPPETS<163,3,1> = "LES(array1, array2)"
    SNIPPETS<164,1> = 'LET'
    SNIPPETS<164,2> = 'Use the LET statement to assign the value of expression to variable.'
    SNIPPETS<164,3,1> = "[LET] variable = expression"
    SNIPPETS<165,1> = 'LN'
    SNIPPETS<165,2> = 'Use the LN function to calculate the natural logarithm of the value of an expression, using base e.'
    SNIPPETS<165,3,1> = "LN(expression)"
    SNIPPETS<166,1> = 'LOCATE'
    SNIPPETS<166,2> = 'Find in dynamic array'
    SNIPPETS<166,3,1> = "LOCATE(NEEDLE,HAYSTACK;ANYPOS) ELSE POS = 0"
    SNIPPETS<167,1> = 'LOCALEINFO'
    SNIPPETS<167,2> = 'In NLS mode, use the LOCALEINFO function to retrieve the settings of the current locale.'
    SNIPPETS<167,3,1> = "LOCALEINFO(category)"
    SNIPPETS<168,1> = 'LOCK'
    SNIPPETS<168,2> = 'Use the LOCK statement to protect specified user-defined resources or events against unauthorized use or simultaneous data file access by different users.'
    SNIPPETS<168,3,1> = "LOCK expression [THEN statements] [ELSE statements]"
    SNIPPETS<169,1> = 'LOOP'
    SNIPPETS<169,2> = 'Use the LOOP statement to start a LOOPREPEAT program loop.'
    SNIPPETS<169,3,1> = "LOOP"
    SNIPPETS<169,3,2> = "READNEXT  ELSE  = ''"
    SNIPPETS<169,3,3> = "UNTIL  = '' DO"
    SNIPPETS<169,3,4> = "REPEAT"
    SNIPPETS<170,1> = 'LOWER'
    SNIPPETS<170,2> = 'Use the LOWER function to return a value equal to expression, except that system delimiters which appear in expression are converted to the next lower-level delimiter: field marks are changed to value marks, value marks are changed to subvalue marks, and so on.'
    SNIPPETS<170,3,1> = "LOWER()"
    SNIPPETS<171,1> = 'LTS'
    SNIPPETS<171,2> = 'Use the LTS function to test if elements of one dynamic array are less than elements of another dynamic array.'
    SNIPPETS<171,3,1> = "LTS(array1, array2)"
    SNIPPETS<172,1> = 'MAT'
    SNIPPETS<172,2> = 'Use the MAT statement to assign one value to all of the elements in the array or to assign all the values of one array to the values of another array.'
    SNIPPETS<172,3,1> = "MAT  = ''"
    SNIPPETS<173,1> = 'MATBUILD'
    SNIPPETS<173,2> = 'Use the MATBUILD statement to build a dynamic array from a dimensioned array.'
    SNIPPETS<173,3,1> = "MATBUILD dynamic.array FROM array [,start [,end]] [USING delimiter]"
    SNIPPETS<174,1> = 'MATCHFIELD'
    SNIPPETS<174,2> = 'Use the MATCHFIELD function to check a string against a match pattern.'
    SNIPPETS<174,3,1> = "MATCHFIELD(string, pattern, field)"
    SNIPPETS<175,1> = 'MATPARSE'
    SNIPPETS<175,2> = 'Use the MATPARSE statement to separate the fields of dynamic.'
    SNIPPETS<175,3,1> = "MATPARSE array FROM dynamic.array [,delimiter]"
    SNIPPETS<176,1> = 'MATREAD'
    SNIPPETS<176,2> = 'Use the MATREAD statement to assign the contents of the fields of a record from a UniVerse file to consecutive elements of array.'
    SNIPPETS<176,3,1> = "MATREAD  FROM .FILE, .ID ELSE MAT  = ''"
    SNIPPETS<177,1> = 'MATWRITE'
    SNIPPETS<177,2> = 'Use the MATWRITE statement to write data from the elements of a dimensioned array to a record in a UniVerse file.'
    SNIPPETS<177,3,1> = "MATWRITE .ITEM ON .FILE,.ID"
    SNIPPETS<178,1> = 'MAXIMUM'
    SNIPPETS<178,2> = 'Use the MAXIMUM function to return the element with the highest numeric value in dynamic.'
    SNIPPETS<178,3,1> = "MAXIMUM(dynamic.array)"
    SNIPPETS<179,1> = 'MINIMUM'
    SNIPPETS<179,2> = 'Use the MINIMUM function to return the element with the lowest numeric value in dynamic.'
    SNIPPETS<179,3,1> = "MINIMUM(dynamic.array)"
    SNIPPETS<180,1> = 'MOD'
    SNIPPETS<180,2> = 'Use the MOD function to calculate the value of the remainder after integer division is performed on the dividend expression by the divisor expression.'
    SNIPPETS<180,3,1> = "MOD(dividend, divisor)"
    SNIPPETS<181,1> = 'MODS'
    SNIPPETS<181,2> = 'Use the MODS function to create a dynamic array of the remainder after the integer division of corresponding elements of two dynamic arrays.'
    SNIPPETS<181,3,1> = "MODS(array1, array2)"
    SNIPPETS<182,1> = 'MQCLOSE'
    SNIPPETS<182,2> = 'Use the MQCLOSE() function to close access to a queue or other object.'
    SNIPPETS<182,3,1> = "status=MQCLOSE(hConn, hObj, options)"
    SNIPPETS<183,1> = 'MQCONN'
    SNIPPETS<183,2> = 'The MQCONN() function connects an application to a WebSphere MQ queue manager.'
    SNIPPETS<183,3,1> = "status=MQCONN(qManager, hConn)"
    SNIPPETS<184,1> = 'MQDISC'
    SNIPPETS<184,2> = 'The MQDISC function terminates connections to the queue manager that were create using the MQCONN function.'
    SNIPPETS<184,3,1> = "status=MQDISC(hConn)"
    SNIPPETS<185,1> = 'MULS'
    SNIPPETS<185,2> = 'Use the MULS function to create a dynamic array of the element-by-element multiplication of two dynamic arrays.'
    SNIPPETS<185,3,1> = "MULS(array1, array2)"
    SNIPPETS<186,1> = 'NAP'
    SNIPPETS<186,2> = 'Use the NAP statement to suspend the execution of a BASIC program, pausing for a specified number of milliseconds.'
    SNIPPETS<186,3,1> = "NAP [milliseconds]"
    SNIPPETS<187,1> = 'NEG'
    SNIPPETS<187,2> = 'Use the NEG function to return the arithmetic inverse of the value of the argument.'
    SNIPPETS<187,3,1> = "NEG(number)"
    SNIPPETS<188,1> = 'NEGS'
    SNIPPETS<188,2> = 'Use the NEGS function to return the negative values of all the elements in a dynamic array.'
    SNIPPETS<188,3,1> = "NEGS(dynamic.array)"
    SNIPPETS<189,1> = 'NES'
    SNIPPETS<189,2> = 'Use the NES function to test if elements of one dynamic array are equal to the elements of another dynamic array.'
    SNIPPETS<189,3,1> = "NES(array1, array2)"
    SNIPPETS<190,1> = 'NEXT'
    SNIPPETS<190,2> = 'Use the NEXT statement to end a FORNEXT loop, causing the program to branch back to the FOR statement and execute the statements that follow it.'
    SNIPPETS<190,3,1> = "NEXT [variable]"
    SNIPPETS<191,1> = 'NOBUF'
    SNIPPETS<191,2> = 'Use the NOBUF statement to turn off buffering for a file previously opened for sequential processing.'
    SNIPPETS<191,3,1> = "NOBUF file.variable {THEN statements [ELSE statements] | ELSE"
    SNIPPETS<192,1> = 'NOT'
    SNIPPETS<192,2> = 'Use the NOT function to return the logical complement of the value of expression.'
    SNIPPETS<192,3,1> = "NOT(expression)"
    SNIPPETS<193,1> = 'NOTS'
    SNIPPETS<193,2> = 'Use the NOTS function to return a dynamic array of the logical complements of each element of dynamic.'
    SNIPPETS<193,3,1> = "NOTS(dynamic.array)"
    SNIPPETS<194,1> = 'NULL'
    SNIPPETS<194,2> = 'Use the NULL statement when a statement is required but no operation is to be performed.'
    SNIPPETS<194,3,1> = "NULL"
    SNIPPETS<195,1> = 'NUM'
    SNIPPETS<195,2> = 'Use the NUM function to determine whether expression is a numeric or nonnumeric string.'
    SNIPPETS<195,3,1> = "NUM(expression)"
    SNIPPETS<196,1> = 'NUMS'
    SNIPPETS<196,2> = 'Use the NUMS function to determine whether the elements of a dynamic array are numeric or nonnumeric strings.'
    SNIPPETS<196,3,1> = "NUMS(dynamic.array)"
    SNIPPETS<197,1> = 'OCONV'
    SNIPPETS<197,2> = 'Use the OCONV function to convert string to a specified format for external output.'
    SNIPPETS<197,3,1> = "OCONV(, '')"
    SNIPPETS<198,1> = 'OCONVS'
    SNIPPETS<198,2> = 'Use the OCONVS function to convert the elements of dynamic.'
    SNIPPETS<198,3,1> = "OCONVS(dynamic.array, conversion)"
    SNIPPETS<199,1> = 'ON'
    SNIPPETS<199,2> = 'Use the ON statement to transfer program control to one of the internal subroutines named in the GOSUB clause or to one of the statements named in the GOTO clause.'
    SNIPPETS<199,3,1> = "ON expression GOSUB statement.label [:] [,statement.label [:] ]"
    SNIPPETS<200,1> = 'OPEN'
    SNIPPETS<200,2> = 'Use the OPEN statement to open a UniVerse file for use by BASIC programs.'
    SNIPPETS<200,3,1> = "OPEN '','' TO .FILE ELSE"
    SNIPPETS<200,3,2> = "PRINT 'Unable to open file:  - Press RETURN':"
    SNIPPETS<200,3,3> = "INPUT ANYTHING"
    SNIPPETS<200,3,4> = "STOP"
    SNIPPETS<200,3,5> = "END"
    SNIPPETS<201,1> = 'OPENCHECK'
    SNIPPETS<201,2> = 'Use the OPENCHECK statement to open an SQL table for use by BASIC programs, enforcing SQL integrity checking.'
    SNIPPETS<201,3,1> = "OPENCHECK [dict,] filename [TO file.variable] {THEN statements [ELSE"
    SNIPPETS<202,1> = 'OPENDEV'
    SNIPPETS<202,2> = 'Use the OPENDEV statement to open a device for sequential processing.'
    SNIPPETS<202,3,1> = "OPENDEV device TO file.variable [LOCKED statements] {THEN statements"
    SNIPPETS<203,1> = 'OPENPATH'
    SNIPPETS<203,2> = 'The OPENPATH statement is similar to the OPEN statement, except that the pathname of the file is specified.'
    SNIPPETS<203,3,1> = "OPENPATH pathname [TO file.variable] [ON ERROR statements] {THEN"
    SNIPPETS<204,1> = 'OPENSEQ'
    SNIPPETS<204,2> = 'Use the OPENSEQ statement to open a file for sequential processing.'
    SNIPPETS<204,3,1> = "OPENSEQ filename, record.ID TO file.variable [USING dynamic.array]"
    SNIPPETS<205,1> = 'ORS'
    SNIPPETS<205,2> = 'Use the ORS function to create a dynamic array of the logical OR of corresponding elements of two dynamic arrays.'
    SNIPPETS<205,3,1> = "ORS(array1, array2)"
    SNIPPETS<206,1> = 'PAGE'
    SNIPPETS<206,2> = 'Use the PAGE statement to print headings, footings, and page advances at the appropriate places on the specified output device.'
    SNIPPETS<206,3,1> = "PAGE [ON print.channel] [page#]"
    SNIPPETS<207,1> = 'PERFORM'
    SNIPPETS<207,2> = 'Use the PERFORM statement to execute a UniVerse sentence, paragraph, menu, or command from within the BASIC program, then return execution to the statement following the PERFORM statement.'
    SNIPPETS<207,3,1> = "PERFORM "
    SNIPPETS<208,1> = 'PRECISION'
    SNIPPETS<208,2> = 'Use the PRECISION statement to control the maximum number of decimal places that are output when the system converts a numeric value from internal binary format to an ASCII character string value.'
    SNIPPETS<208,3,1> = "PRECISION "
    SNIPPETS<209,1> = 'PRINT'
    SNIPPETS<209,2> = 'Use the PRINT statement to send data to the screen, a line printer, or another print file.'
    SNIPPETS<209,3,1> = "PRINT "
    SNIPPETS<210,1> = 'PRINTER'
    SNIPPETS<210,2> = 'Use the PRINTER statement to direct output either to the screen or to a printer.'
    SNIPPETS<210,3,1> = "PRINTER "
    SNIPPETS<211,1> = 'PRINTERR'
    SNIPPETS<211,2> = 'Use the PRINTERR statement to print a formatted error message on the bottom line of the terminal.'
    SNIPPETS<211,3,1> = "PRINTERR "
    SNIPPETS<212,1> = 'PROCREAD'
    SNIPPETS<212,2> = 'Use the PROCREAD statement to assign the contents of the primary input buffer to a variable.'
    SNIPPETS<212,3,1> = "PROCREAD  ELSE  = ''"
    SNIPPETS<213,1> = 'PROCWRITE'
    SNIPPETS<213,2> = 'Use the PROCWRITE statement to write string to the primary input buffer.'
    SNIPPETS<213,3,1> = "PROCWRITE "
    SNIPPETS<214,1> = 'PROGRAM'
    SNIPPETS<214,2> = 'Use the PROGRAM statement to identify a program.'
    SNIPPETS<214,3,1> = "PROG[RAM] [name]"
    SNIPPETS<215,1> = 'PROMPT'
    SNIPPETS<215,2> = 'Use the PROMPT statement to specify the character to be displayed on the screen when user input is required.'
    SNIPPETS<215,3,1> = "PROMPT "
    SNIPPETS<216,1> = 'PWR'
    SNIPPETS<216,2> = 'Use the PWR function to return the value of expression raised to the power specified by power.'
    SNIPPETS<216,3,1> = "PWR(, )"
    SNIPPETS<217,1> = 'QUOTE'
    SNIPPETS<217,2> = 'Use the QUOTE function to enclose an expression in double quotation marks.'
    SNIPPETS<217,3,1> = "QUOTE()"
    SNIPPETS<218,1> = 'RAISE'
    SNIPPETS<218,2> = 'Use the RAISE function to return a value equal to expression, except that system delimiters in expression are converted to the next higher-level delimiter: value marks are changed to field marks, subvalue marks are changed to value marks, and so on.'
    SNIPPETS<218,3,1> = "RAISE()"
    SNIPPETS<219,1> = 'RANDOMIZE'
    SNIPPETS<219,2> = 'Use the RANDOMIZE statement with an expression to make the RND function generate the same sequence of random numbers each time the program is run.'
    SNIPPETS<219,3,1> = "RANDOMIZE [(expression)]"
    SNIPPETS<220,1> = 'READ'
    SNIPPETS<220,2> = 'Use READ statements to assign the contents of a record from a UniVerse file to dynamic.'
    SNIPPETS<220,3,1> = "READ  FROM , ITEM.ID ELSE = ''"
    SNIPPETS<221,1> = 'READBLK'
    SNIPPETS<221,2> = 'Use the READBLK statement to read a block of data of a specified length from a file opened for sequential processing and assign it to a variable.'
    SNIPPETS<221,3,1> = "READBLK variable FROM file.variable, blocksize THEN statements [ELSE"
    SNIPPETS<222,1> = 'READLIST'
    SNIPPETS<222,2> = 'Use the READLIST statement to read the remainder of an active select list into a dynamic array.'
    SNIPPETS<222,3,1> = "READLIST dynamic.array [FROM list.number] { THEN statements [ELSE"
    SNIPPETS<223,1> = 'READNEXT'
    SNIPPETS<223,2> = 'Use the READNEXT statement to assign the next record ID from an active select list to dynamic.'
    SNIPPETS<223,3,1> = "READNEXT  ELSE  = ''"
    SNIPPETS<224,1> = 'READSEQ'
    SNIPPETS<224,2> = 'Use the READSEQ statement to read a line of data from a file opened for sequential processing.'
    SNIPPETS<224,3,1> = "READSEQ variable FROM file.variable [ON ERROR statements] {THEN"
    SNIPPETS<225,1> = 'READT'
    SNIPPETS<225,2> = 'Use the READT statement to read the next tape record from a magnetic tape unit and assign its contents to a variable.'
    SNIPPETS<225,3,1> = "READT [UNIT(mtu)] variable {THEN statements [ELSE statements] | ELSE"
    SNIPPETS<226,1> = 'READVU'
    SNIPPETS<226,2> = 'Use the READVU statement to set an update record lock and read the contents of a specified field of a record in a UniVerse file.'
    SNIPPETS<226,3,1> = "Status=ReadXMLData(xml_data_handle, rec)"
    SNIPPETS<227,1> = 'REAL'
    SNIPPETS<227,2> = 'Use the REAL function to convert number into a floating-point number without loss of accuracy.'
    SNIPPETS<227,3,1> = "REAL(number)"
    SNIPPETS<228,1> = 'RECORDLOCK'
    SNIPPETS<228,2> = 'Use RECORDLOCK statements to acquire a record lock on a record without reading the record.'
    SNIPPETS<228,3,1> = "RECORDLOCKL file.variable , record.ID [ON ERROR statements] [LOCKED"
    SNIPPETS<229,1> = 'RECORDLOCKED'
    SNIPPETS<229,2> = 'Use the RECORDLOCKED function to return the status of a record lock.'
    SNIPPETS<229,3,1> = "RECORDLOCKED(file.variable , record.ID )"
    SNIPPETS<230,1> = 'RELEASE'
    SNIPPETS<230,2> = 'Use the RELEASE statement to unlock, or release, locks set by a FILELOCK statement, MATREADL statement, MATREADU statement, READL statement, READU statement, READVL statement, READVU statement, and OPENSEQ statement.'
    SNIPPETS<230,3,1> = "RELEASE [file.variable [,record.ID]] [ON ERROR statements]"
    SNIPPETS<231,1> = 'REM'
    SNIPPETS<231,2> = 'Use the REM statement to insert a comment in a BASIC program.'
    SNIPPETS<231,3,1> = "REM [comment.text]"
    SNIPPETS<232,1> = 'REMOVE'
    SNIPPETS<232,2> = 'Use the REMOVE statement to successively extract dynamic array elements that are separated by system delimiters.'
    SNIPPETS<232,3,1> = "REMOVE element FROM dynamic.array SETTING variable"
    SNIPPETS<233,1> = 'REPLACE'
    SNIPPETS<233,2> = 'Use the REPLACE function to return a copy of a dynamic array with the specified field, value, or subvalue replaced with new data.'
    SNIPPETS<233,3,1> = "REPLACE(expression, field#, value#, subvalue# { , | ; } replacement)"
    SNIPPETS<234,1> = 'RETURN'
    SNIPPETS<234,2> = 'Use the RETURN statement to terminate a subroutine and return control to the calling program or statement.'
    SNIPPETS<234,3,1> = "RETURN"
    SNIPPETS<235,1> = 'REUSE'
    SNIPPETS<235,2> = 'Use the REUSE function to specify that the value of the last field, value, or subvalue be reused in a dynamic array operation.'
    SNIPPETS<235,3,1> = "REUSE(expression)"
    SNIPPETS<236,1> = 'REVREMOVE'
    SNIPPETS<236,2> = 'Use the REVREMOVE statement to successively extract dynamic array elements that are separated by system delimiters.'
    SNIPPETS<236,3,1> = "REVREMOVE element FROM dynamic.array SETTING variable"
    SNIPPETS<237,1> = 'REWIND'
    SNIPPETS<237,2> = 'Use the REWIND statement to rewind a magnetic tape to the beginning-of-tape position.'
    SNIPPETS<237,3,1> = "REWIND [UNIT(mtu)] {THEN statements [ELSE statements] | ELSE"
    SNIPPETS<238,1> = 'RIGHT'
    SNIPPETS<238,2> = 'Use the RIGHT function to extract a substring comprising the last n characters of a string.'
    SNIPPETS<238,3,1> = "RIGHT(string, n)"
    SNIPPETS<239,1> = 'RND'
    SNIPPETS<239,2> = 'Use the RND function to generate any positive or negative random integer or 0.'
    SNIPPETS<239,3,1> = "RND(expression)"
    SNIPPETS<240,1> = 'ROLLBACK'
    SNIPPETS<240,2> = 'Use the ROLLBACK statement to cancel all file I/O changes made during a transaction.'
    SNIPPETS<240,3,1> = "ROLLBACK [WORK] [THEN statements] [ELSE statements ]"
    SNIPPETS<241,1> = 'ROUND'
    SNIPPETS<241,2> = 'Use the ROUND function to round a numeric value to the specified number of decimal places.'
    SNIPPETS<241,3,1> = "ROUND(number,places)"
    SNIPPETS<242,1> = 'SADD'
    SNIPPETS<242,2> = 'Use the SADD function to add two string numbers and return the result as a string number.'
    SNIPPETS<242,3,1> = "SADD(string.number.1, string.number.2)"
    SNIPPETS<243,1> = 'SCMP'
    SNIPPETS<243,2> = 'Use the SCMP function to compare two string numbers and return one of the following three numbers: can use this function in any expression where a string or string number is valid.'
    SNIPPETS<243,3,1> = "SCMP(string.number.1, string.number.2)"
    SNIPPETS<244,1> = 'SDIV'
    SNIPPETS<244,2> = 'Use the SDIV function to divide string.'
    SNIPPETS<244,3,1> = "SDIV(string.number.1, string.number.2 [,precision])"
    SNIPPETS<245,1> = 'SEEK'
    SNIPPETS<245,2> = 'Use the SEEK statement to move the file pointer by an offset specified in bytes, relative to the current position, the beginning of the file, or the end of the file.'
    SNIPPETS<245,3,1> = "SEEK file.variable [, offset [, relto]] {THEN statements [ELSE"
    SNIPPETS<246,1> = 'SELECT'
    SNIPPETS<246,2> = 'Use a SELECT statement to create a numbered select list of record IDs from a UniVerse file or a dynamic array.'
    SNIPPETS<246,3,1> = "SELECT "
    SNIPPETS<247,1> = 'SELECTE'
    SNIPPETS<247,2> = 'Use the SELECTE statement to assign the contents of select list 0 to list.'
    SNIPPETS<247,3,1> = "SELECTE TO list.variable"
    SNIPPETS<248,1> = 'SELECTINDEX'
    SNIPPETS<248,2> = 'Use the SELECTINDEX statement to create select lists from secondary indexes.'
    SNIPPETS<248,3,1> = "SELECTINDEX index [, alt.key] FROM file.variable [TO list.number]"
    SNIPPETS<249,1> = 'SELECTINFO'
    SNIPPETS<249,2> = 'Use the SELECTINFO function to determine whether a select list is active, or to determine the number of items it contains.'
    SNIPPETS<249,3,1> = "SELECTINFO(list, key)"
    SNIPPETS<250,1> = 'SEND'
    SNIPPETS<250,2> = 'Use the SEND statement to write a block of data to a device.'
    SNIPPETS<250,3,1> = "SEND output [:] TO device { THEN statements [ELSE statements] | ELSE"
    SNIPPETS<251,1> = 'SENTENCE'
    SNIPPETS<251,2> = 'Use the SENTENCE function to return the stored sentence that invoked the current process.'
    SNIPPETS<251,3,1> = "SENTENCE()"
    SNIPPETS<252,1> = 'SEQ'
    SNIPPETS<252,2> = 'Use the SEQ function to convert an ASCII character to its numeric string equivalent.'
    SNIPPETS<252,3,1> = "SEQ(expression)"
    SNIPPETS<253,1> = 'SEQS'
    SNIPPETS<253,2> = 'Use the SEQS function to convert a dynamic array of ASCII characters to their numeric string equivalents.'
    SNIPPETS<253,3,1> = "SEQS(dynamic.array)"
    SNIPPETS<254,1> = 'SETLOCALE'
    SNIPPETS<254,2> = 'In NLS mode, use the SETLOCALE function to enable or disable a locale for a specified category or change its setting.'
    SNIPPETS<254,3,1> = "SETLOCALE(category, value)"
    SNIPPETS<255,1> = 'SETREM'
    SNIPPETS<255,2> = 'Use the SETREM statement to set the remove pointer in dynamic.'
    SNIPPETS<255,3,1> = "SETREM position ON dynamic.array"
    SNIPPETS<256,1> = 'SIGNATURE'
    SNIPPETS<256,2> = 'The SIGNATURE() function generates a digital signature or verifies a signature using the supplied key.'
    SNIPPETS<256,3,1> = "SIGNATURE(algorithm, action, data, dataLoc, key, keyLoc, keyFmt, pass,"
    SNIPPETS<257,1> = 'SIN'
    SNIPPETS<257,2> = 'Use the SIN function to return the trigonometric sine of an expression.'
    SNIPPETS<257,3,1> = "SIN(expression)"
    SNIPPETS<258,1> = 'SINH'
    SNIPPETS<258,2> = 'Use the SINH function to return the hyperbolic sine of expression.'
    SNIPPETS<258,3,1> = "SINH(expression)"
    SNIPPETS<259,1> = 'SLEEP'
    SNIPPETS<259,2> = 'Use the SLEEP statement to suspend execution of a BASIC program, pausing for a specified number of seconds.'
    SNIPPETS<259,3,1> = "SLEEP [seconds]"
    SNIPPETS<260,1> = 'SMUL'
    SNIPPETS<260,2> = 'Use the SMUL function to multiply two string numbers and return the result as a string number.'
    SNIPPETS<260,3,1> = "SMUL(string.number.1, string.number.2)"
    SNIPPETS<261,1> = 'SOUNDEX'
    SNIPPETS<261,2> = 'The SOUNDEX function evaluates expression and returns the most significant letter in the input string followed by a phonetic code.'
    SNIPPETS<261,3,1> = "SOUNDEX(expression)"
    SNIPPETS<262,1> = 'SPACE'
    SNIPPETS<262,2> = 'Use the SPACE function to return a string composed of blank spaces.'
    SNIPPETS<262,3,1> = "SPACE(expression)"
    SNIPPETS<263,1> = 'SPACES'
    SNIPPETS<263,2> = 'Use the SPACES function to return a dynamic array with elements composed of blank spaces.'
    SNIPPETS<263,3,1> = "SPACES(dynamic.array)"
    SNIPPETS<264,1> = 'SPLICE'
    SNIPPETS<264,2> = 'Use the SPLICE function to create a dynamic array of the element-by-element concatenation of two dynamic arrays, separating concatenated elements by the value of expression.'
    SNIPPETS<264,3,1> = "SPLICE(array1, expression, array2)"
    SNIPPETS<265,1> = 'SQUOTE'
    SNIPPETS<265,2> = 'Use the SQUOTE function to enclose an expression in single quotation marks.'
    SNIPPETS<265,3,1> = "SQUOTE(expression)"
    SNIPPETS<266,1> = 'SSELECT'
    SNIPPETS<266,2> = 'Use an SSELECT statement to create:   A numbered select list of record IDs in sorted order from a UniVerse file  A numbered select list of record IDs from a dynamic array.'
    SNIPPETS<266,3,1> = "SSELECT [variable] [TO list.number] [ON ERROR statements]"
    SNIPPETS<267,1> = 'SSUB'
    SNIPPETS<267,2> = 'Use the SSUB function to subtract string.'
    SNIPPETS<267,3,1> = "SSUB(string.number.1, string.number.2)"
    SNIPPETS<268,1> = 'STATUS'
    SNIPPETS<268,2> = 'Use the STATUS statement to determine the status of an open file.'
    SNIPPETS<268,3,1> = "STATUS dynamic.array FROM file.variable {THEN statements [ELSE"
    SNIPPETS<269,1> = 'STOP'
    SNIPPETS<269,2> = 'Use the STOP statement to terminate program execution and return system control to the invoking process.'
    SNIPPETS<269,3,1> = "STOP [expression]"
    SNIPPETS<270,1> = 'STORAGE'
    SNIPPETS<270,2> = 'The STORAGE statement performs no function.'
    SNIPPETS<270,3,1> = "STORAGE arg1arg2arg3"
    SNIPPETS<271,1> = 'STR'
    SNIPPETS<271,2> = 'Use the STR function to produce a specified number of repetitions of a particular character string.'
    SNIPPETS<271,3,1> = "STR(string, repeat)"
    SNIPPETS<272,1> = 'STRS'
    SNIPPETS<272,2> = 'Use the STRS function to produce a dynamic array containing the specified number of repetitions of each element of dynamic.'
    SNIPPETS<272,3,1> = "STRS(dynamic.array, repeat)"
    SNIPPETS<273,1> = 'SUBR'
    SNIPPETS<273,2> = 'Use the SUBR function to return the value of an external subroutine.'
    SNIPPETS<273,3,1> = "SUBR(name, [argument [,argument ]] )"
    SNIPPETS<274,1> = 'SUBROUTINE'
    SNIPPETS<274,2> = 'Use the SUBROUTINE statement to identify an external subroutine.'
    SNIPPETS<274,3,1> = "SUBROUTINE ()"
    SNIPPETS<275,1> = 'SUBS'
    SNIPPETS<275,2> = 'Use the SUBS function to create a dynamic array of the element-by-element subtraction of two dynamic arrays.'
    SNIPPETS<275,3,1> = "SUBS(array1, array2)"
    SNIPPETS<276,1> = 'SUBSTRINGS'
    SNIPPETS<276,2> = 'Use the SUBSTRINGS function to create a dynamic array each of whose elements are substrings of the corresponding elements of dynamic.'
    SNIPPETS<276,3,1> = "SUBSTRINGS(dynamic.array, start, length)"
    SNIPPETS<277,1> = 'SUM'
    SNIPPETS<277,2> = 'Use the SUM function to calculate the sum of numeric data.'
    SNIPPETS<277,3,1> = "SUM(dynamic.array)"
    SNIPPETS<278,1> = 'SUMMATION'
    SNIPPETS<278,2> = 'Use the SUMMATION function to return the sum of all the elements in dynamic.'
    SNIPPETS<278,3,1> = "SUMMATION(dynamic.array)"
    SNIPPETS<279,1> = 'SWAP'
    SNIPPETS<279,2> = 'The SWAP statement interchanges the values in the variables you specify.'
    SNIPPETS<279,3,1> = "For variables: SWAP variable1, variable2"
    SNIPPETS<280,1> = 'SYSTEM'
    SNIPPETS<280,2> = 'Use the SYSTEM function to check on the status of a system function.'
    SNIPPETS<280,3,1> = "SYSTEM(expression)"
    SNIPPETS<281,1> = 'TABSTOP'
    SNIPPETS<281,2> = 'Use the TABSTOP statement to set the current tabstop width for PRINT statement.'
    SNIPPETS<281,3,1> = "TABSTOP expression"
    SNIPPETS<282,1> = 'TAN'
    SNIPPETS<282,2> = 'Use the TAN function to return the trigonometric tangent of expression.'
    SNIPPETS<282,3,1> = "TAN(expression)"
    SNIPPETS<283,1> = 'TANH'
    SNIPPETS<283,2> = 'Use the TANH function to return the hyperbolic tangent of expression.'
    SNIPPETS<283,3,1> = "TANH(expression)"
    SNIPPETS<284,1> = 'TERMINFO'
    SNIPPETS<284,2> = 'Use the TERMINFO function to access the device-independent terminal handler string defined for the current terminal type.'
    SNIPPETS<284,3,1> = "TERMINFO(argument)"
    SNIPPETS<285,1> = 'TIME'
    SNIPPETS<285,2> = 'Use the TIME function to return a string value expressing the internal time of day.'
    SNIPPETS<285,3,1> = "TIME()"
    SNIPPETS<286,1> = 'TIMEDATE'
    SNIPPETS<286,2> = 'Use the TIMEDATE function to return the current system time and date.'
    SNIPPETS<286,3,1> = "TIMEDATE()"
    SNIPPETS<287,1> = 'TIMEOUT'
    SNIPPETS<287,2> = 'Use the TIMEOUT statement to terminate a READSEQ statement or READBLK statement if no data is read in the specified time.'
    SNIPPETS<287,3,1> = "TIMEOUT {file.variable | link.number}, time"
    SNIPPETS<288,1> = 'TPARM'
    SNIPPETS<288,2> = 'Use the TPARM function to evaluate a parameterized terminfo string.'
    SNIPPETS<288,3,1> = "TPARM(terminfo.string, [arg1], [arg2], [arg3], [arg4], [arg5], [arg6],"
    SNIPPETS<289,1> = 'TPRINT'
    SNIPPETS<289,2> = 'Use the TPRINT statement to send data to the screen, a line printer, or another print file.'
    SNIPPETS<289,3,1> = "TPRINT [ON print.channel] [print.list]"
    SNIPPETS<290,1> = 'TRANS'
    SNIPPETS<290,2> = 'Use the TRANS function to return the contents of a field or a record in a UniVerse file.'
    SNIPPETS<290,3,1> = "TRANS([DICT] filename, record.ID, field#, control.code)"
    SNIPPETS<291,1> = 'TRIM'
    SNIPPETS<291,2> = 'Use the TRIM function to remove unwanted characters in expression.'
    SNIPPETS<291,3,1> = "TRIM(expression [,character [,option]] )"
    SNIPPETS<292,1> = 'TRIMB'
    SNIPPETS<292,2> = 'Use the TRIMB function to remove all trailing spaces and tabs from expression.'
    SNIPPETS<292,3,1> = "TRIMB(expression)"
    SNIPPETS<293,1> = 'TRIMBS'
    SNIPPETS<293,2> = 'Use the TRIMBS function to remove all trailing spaces and tabs from each element of dynamic.'
    SNIPPETS<293,3,1> = "TRIMBS(dynamic.array)"
    SNIPPETS<294,1> = 'TRIMF'
    SNIPPETS<294,2> = 'Use the TRIMF function to remove all leading spaces and tabs from expression.'
    SNIPPETS<294,3,1> = "TRIMF(expression)"
    SNIPPETS<295,1> = 'TRIMFS'
    SNIPPETS<295,2> = 'Use the TRIMFS function to remove all leading spaces and tabs from each element of dynamic.'
    SNIPPETS<295,3,1> = "TRIMFS(dynamic.array)"
    SNIPPETS<296,1> = 'TRIMS'
    SNIPPETS<296,2> = 'Use the TRIMS function to remove unwanted spaces and tabs from each element of dynamic.'
    SNIPPETS<296,3,1> = "TRIMS(dynamic.array)"
    SNIPPETS<297,1> = 'TRUNC'
    SNIPPETS<297,2> = 'Use the TRUNC function to truncate a numeric variable or string to a specified number of decimal places.'
    SNIPPETS<297,3,1> = "TRUNC(number,places)"
    SNIPPETS<298,1> = 'TTYCTL'
    SNIPPETS<298,2> = 'Use the TTYCTL statement to set terminal device characteristics on Berkeley terminal drivers.'
    SNIPPETS<298,3,1> = "TTYCTL file.variable, code# {THEN statements [ELSE statements] | ELSE"
    SNIPPETS<299,1> = 'TTYGET'
    SNIPPETS<299,2> = 'Use the TTYGET statement to assign the characteristics of a terminal, line printer channel, or tape unit as a dynamic array to variable.'
    SNIPPETS<299,3,1> = "TTYGET variable [FROM {file.variable | LPTR [n] | MTU [n] }] THEN"
    SNIPPETS<300,1> = 'TTYSET'
    SNIPPETS<300,2> = 'Use the TTYSET statement to set the characteristics of a terminal, line printer channel, or tape unit.'
    SNIPPETS<300,3,1> = "TTYSET dynamic.array [ON {file.variable | LPTR [n] | MTU [n] }] {THEN"
    SNIPPETS<301,1> = 'UNASSIGNED'
    SNIPPETS<301,2> = 'Use the UNASSIGNED function to determine if variable is unassigned.'
    SNIPPETS<301,3,1> = "UNASSIGNED(variable)"
    SNIPPETS<302,1> = 'UNICHAR'
    SNIPPETS<302,2> = 'Use the UNICHAR function to generate a single character from a Unicode value.'
    SNIPPETS<302,3,1> = "UNICHAR(unicode)"
    SNIPPETS<303,1> = 'UNICHARS'
    SNIPPETS<303,2> = 'Use the UNICHARS function to generate a dynamic array of characters from a dynamic array of Unicode values.'
    SNIPPETS<303,3,1> = "UNICHARS(dynamic.array)"
    SNIPPETS<304,1> = 'UNISEQ'
    SNIPPETS<304,2> = 'Use the UNISEQ function to generate a Unicode value from expression.'
    SNIPPETS<304,3,1> = "UNISEQ(expression)"
    SNIPPETS<305,1> = 'UNISEQS'
    SNIPPETS<305,2> = 'Use the UNISEQS function to generate an array of Unicode values from a dynamic array of characters.'
    SNIPPETS<305,3,1> = "UNISEQS(dynamic.array)"
    SNIPPETS<306,1> = 'UNLOCK'
    SNIPPETS<306,2> = 'Use the UNLOCK statement to release a process lock set by the LOCK statement.'
    SNIPPETS<306,3,1> = "UNLOCK [expression]"
    SNIPPETS<307,1> = 'UPCASE'
    SNIPPETS<307,2> = 'Use the UPCASE function to change all lowercase letters in expression to uppercase.'
    SNIPPETS<307,3,1> = "UPCASE(expression)"
    SNIPPETS<308,1> = 'UPRINT'
    SNIPPETS<308,2> = 'In NLS mode, use the UPRINT statement to print data that was mapped to an external format using OCONV mapname.'
    SNIPPETS<308,3,1> = "UPRINT [ON print.channel] [print.list ]"
    SNIPPETS<309,1> = 'USERINFO'
    SNIPPETS<309,2> = 'Use the USERINFO function to get the pid, user number, and more for the pid or user number specified.'
    SNIPPETS<309,3,1> = "USERINFO(code, value, userinfo)"
    SNIPPETS<310,1> = 'WEOF'
    SNIPPETS<310,2> = 'Use the WEOF statement to write an end-of-file (EOF) mark to tape.'
    SNIPPETS<310,3,1> = "WEOF [UNIT(mtu)] {THEN statements [ELSE statements] | ELSE statements}"
    SNIPPETS<311,1> = 'WEOFSEQ'
    SNIPPETS<311,2> = 'Use the WEOFSEQ statement to write an end-of-file (EOF) mark in a file opened for sequential access.'
    SNIPPETS<311,3,1> = "WEOFSEQfile.variable [ON ERROR statements]"
    SNIPPETS<312,1> = 'WRITE'
    SNIPPETS<312,2> = 'Use WRITE statements to write new data to a record in a UniVerse file.'
    SNIPPETS<312,3,1> = "WRITE  ON .FILE, .ID"
    SNIPPETS<313,1> = 'WRITEBLK'
    SNIPPETS<313,2> = 'Use the WRITEBLK statement to write a block of data to a file opened for sequential processing.'
    SNIPPETS<313,3,1> = "WRITEBLK expression ON file.variable {THEN statements [ELSE statements]"
    SNIPPETS<314,1> = 'WRITELIST'
    SNIPPETS<314,2> = 'Use the WRITELIST statement to save a list as a record in the &SAVEDLISTS& file.'
    SNIPPETS<314,3,1> = "WRITELIST dynamic.array ON listname"
    SNIPPETS<315,1> = 'WRITESEQ'
    SNIPPETS<315,2> = 'Use the WRITESEQ statement to write new lines to a file opened for sequential processing.'
    SNIPPETS<315,3,1> = "WRITESEQ expression {ON | TO} file.variable [ON ERROR statements] {THEN"
    SNIPPETS<316,1> = 'WRITESEQF'
    SNIPPETS<316,2> = 'Use the WRITESEQF statement to write new lines to a file opened for sequential processing, and to ensure that data is physically written to disk (that is, not buffered) before the next statement in the program is executed.'
    SNIPPETS<316,3,1> = "WRITESEQF expression {ON | TO} file.variable [ON ERROR statements]"
    SNIPPETS<317,1> = 'WRITET'
    SNIPPETS<317,2> = 'Use the WRITET statement to write a tape record to tape.'
    SNIPPETS<317,3,1> = "WRITET [UNIT(mtu)] variable {THEN statements [ELSE statements] | ELSE"
    SNIPPETS<318,1> = 'WRITEVU'
    SNIPPETS<318,2> = 'Use the WRITEVU statement to maintain an update record lock while writing on the contents of a specified field of a record of a UniVerse file.'
    SNIPPETS<318,3,1> = "XDOMAddChild(xmlHandle, xpathString, nsMap, nodeHandle,"
    SNIPPETS<319,1> = 'XLATE'
    SNIPPETS<319,2> = 'Use the XLATE function to return the contents of a field or a record in a UniVerse file.'
    SNIPPETS<319,3,1> = "XLATE([DICT] filename, record.ID, field#, control.code)"
    SNIPPETS<320,1> = 'XMLTODB'
    SNIPPETS<320,2> = 'You can also populate the UniVerse database by calling the UniVerse BASIC XMLTODB function.'
    SNIPPETS<320,3,1> = "XMLTODB(xml_document, doc_flag, u2xmapping_rules, u2xmap_ flag, status)"
    SNIPPETS<321,1> = 'XTD'
    SNIPPETS<321,2> = 'Use the XTD function to convert a string of hexadecimal characters to an integer.'
    SNIPPETS<321,3,1> = "XTD(string)"
*
    RETURN
*
* END OF PROGRAM
*
    END
